<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Bat Farm â€” Endless Runner</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0614;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }
    canvas { display: block; cursor: pointer; }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
// =====================================================================
//  BAT FARM â€” Ground Runner  (full feature version)
//  Features: Ghost Racing, Boss Encounters, Procedural Theming,
//            Rhythm Runner, Level Editor
// =====================================================================

const C = document.getElementById('c');
const ctx = C.getContext('2d');
const W = 900, H = 500;
C.width = W; C.height = H;

function resize() {
  const s = Math.min(window.innerWidth / W, window.innerHeight / H);
  C.style.width  = (W * s) + 'px';
  C.style.height = (H * s) + 'px';
}
window.addEventListener('resize', resize);
resize();

// â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const GROUND_Y   = H - 80;
const GRAVITY    = 0.65;
const JUMP_VY    = -13.5;
const JUMP2_VY   = -11.0;
const BAT_W      = 44;
const BAT_H      = 24;
const BAT_FOOT_Y = GROUND_Y;

// â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function lerp(a, b, t) { return a + (b - a) * clamp(t, 0, 1); }
function clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; }
function lerpC(a, b, t) { return Math.round(lerp(a, b, t)); }

// zoneBlend: smoothly interpolates three zone colors based on elapsed
// Each color is [r, g, b]
function zoneBlend(z0, z1, z2) {
  // Zone 0: 0â€“60s, Zone 1: 60â€“120s, Zone 2: 120s+
  const t0 = clamp(elapsed / 60, 0, 1);       // 0->1 over first 60s
  const t1 = clamp((elapsed - 60) / 60, 0, 1); // 0->1 over 60â€“120s
  // blend z0->z1 then z1->z2
  const r = Math.round(lerp(lerp(z0[0], z1[0], t0), z2[0], t1));
  const g = Math.round(lerp(lerp(z0[1], z1[1], t0), z2[1], t1));
  const b = Math.round(lerp(lerp(z0[2], z1[2], t0), z2[2], t1));
  return [r, g, b];
}
function zoneBlendStr(z0, z1, z2) {
  const [r,g,b] = zoneBlend(z0,z1,z2);
  return `rgb(${r},${g},${b})`;
}

// â”€â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let scene = 'start';  // 'start' | 'play' | 'dead' | 'editor'
let score = 0, hiScore = +localStorage.getItem('batfarm_hi') || 0;
let elapsed = 0, speed = 1.0, frame = 0, startMs = 0;
let obstacles = [], particles = [];
let spawnTimer = 0;
let shakeFrames = 0, shakeX = 0, shakeY = 0;
let scorePopScale = 1, scorePopFrames = 0;

// â”€â”€â”€ Ghost Racing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let ghostRecord = [];     // recorded during current run (every 5 frames)
let ghostData   = [];     // loaded from localStorage (best-run ghost)
let ghostFrame  = 0;      // index into ghostData during playback

function loadGhost() {
  try {
    const raw = localStorage.getItem('batfarm_ghost');
    ghostData = raw ? JSON.parse(raw) : [];
  } catch(e) { ghostData = []; }
}
function saveGhost() {
  localStorage.setItem('batfarm_ghost', JSON.stringify(ghostRecord));
}
loadGhost();

// â”€â”€â”€ Boss Encounters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let bossActive    = false;
let bossTimer     = 0;     // frames since boss started
const BOSS_DURATION = 12;  // seconds
let bossesTriggered = new Set();
const BOSS_TIMES  = [60, 120, 180]; // seconds
let bossPulse     = 0;

// â”€â”€â”€ Rain / Storm â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let rainDrops = Array.from({length: 200}, () => ({
  x: Math.random() * W,
  y: Math.random() * H,
  len: 8 + Math.random() * 12,
  speed: 6 + Math.random() * 4,
}));
let lightningFlash = 0;       // frames remaining for lightning
let nextLightning  = 0;       // elapsed seconds for next lightning event

// â”€â”€â”€ Rhythm Runner (Web Audio) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const BPM = 110;
const BEAT_MS = 60000 / BPM;  // ~545ms
let audioCtx    = null;
let nextBeatTime = 0;  // AudioContext time
let beatNumber  = 0;
let beatPulse   = 0;   // frames remaining for ground pulse
let beatPulseX  = 0;
let jumpRating  = null; // { text, color, life, y }
let beatTimes   = [];   // recent scheduled beat AudioContext times (for jump timing)
const SCHED_AHEAD = 2.0; // seconds to schedule ahead

function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  nextBeatTime = audioCtx.currentTime + 0.1;
  beatNumber   = 0;
  beatTimes    = [];
}

function scheduleBeat(time) {
  const osc  = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.frequency.value = 220;
  osc.type = 'sine';
  gain.gain.setValueAtTime(0.15, time);
  gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start(time);
  osc.stop(time + 0.06);
  beatTimes.push(time);
  if (beatTimes.length > 20) beatTimes.shift();
}

function runBeatScheduler() {
  if (!audioCtx || scene !== 'play') return;
  const now = audioCtx.currentTime;
  while (nextBeatTime < now + SCHED_AHEAD) {
    scheduleBeat(nextBeatTime);
    nextBeatTime += BEAT_MS / 1000;
    beatNumber++;
  }
  // trigger visual pulse for beats that just fired
  if (beatTimes.length > 0) {
    const last = beatTimes[beatTimes.length - 1];
    if (Math.abs(last - now) < 0.03) {
      beatPulse = 15;
      beatPulseX = 0;
    }
  }
}

function checkJumpRhythm() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  let nearest = Infinity;
  for (const bt of beatTimes) {
    const diff = Math.abs(now - bt) * 1000; // ms
    if (diff < nearest) nearest = diff;
  }
  let text, color;
  if (nearest <= 60) {
    score += 50;
    text = 'PERFECT!'; color = '#44ff44';
    scorePopScale = 1.4; scorePopFrames = 18;
  } else if (nearest <= 140) {
    score += 20;
    text = 'GOOD!'; color = '#ffee44';
    scorePopScale = 1.2; scorePopFrames = 12;
  } else {
    text = 'MISS'; color = '#aaaaaa';
  }
  jumpRating = { text, color, life: 40, y: bat.y - 10 };
}

// â”€â”€â”€ Bat â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const bat = {
  x: 130,
  y: BAT_FOOT_Y - BAT_H,
  vy: 0,
  grounded: true,
  jumpsLeft: 2,
  wingPhase: 0,
  legPhase: 0,
  wx: 1, wy: 1,
  flashFrames: 0,
};

// â”€â”€â”€ World layers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let silos, cropRows, stars;
function initWorld() {
  silos = Array.from({length: 6}, (_, i) => ({
    x: i * 185 + Math.random() * 60,
    kind: Math.random() < 0.55 ? 'silo' : 'tree',
    h: 55 + Math.random() * 45,
  }));
  cropRows = Array.from({length: 14}, (_, i) => ({ x: i * 70 }));
  stars = Array.from({length: 90}, () => ({
    x: Math.random() * W, y: Math.random() * GROUND_Y * 0.6,
    r: Math.random() * 1.4 + 0.3, tw: Math.random() * Math.PI * 2,
  }));
}
initWorld();

// â”€â”€â”€ Plant Defs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PLANT_DEFS = {
  mushroom:  { w: 28, h: 38 },
  sunflower: { w: 22, h: 72 },
  cactus:    { w: 26, h: 58 },
  bush:      { w: 58, h: 32 },
  tallgrass: { w: 18, h: 62 },
};

const PATTERNS = [
  [{ t:'mushroom', dx:0 }],
  [{ t:'bush',     dx:0 }],
  [{ t:'cactus',   dx:0 }],
  [{ t:'tallgrass',dx:0 }],
  [{ t:'sunflower',dx:0 }],
  [{ t:'mushroom', dx:0 }, { t:'mushroom', dx:38 }],
  [{ t:'cactus',   dx:0 }, { t:'bush',     dx:44 }],
  [{ t:'mushroom', dx:0 }, { t:'sunflower',dx:44 }],
  [{ t:'bush',     dx:0 }, { t:'tallgrass',dx:70 }],
  [{ t:'mushroom', dx:0 }, { t:'cactus',   dx:50 }, { t:'mushroom', dx:95 }],
];

function availablePatterns() {
  if (elapsed < 20) return [0, 1];
  if (elapsed < 45) return [0, 1, 2, 3, 4];
  if (elapsed < 80) return [0, 1, 2, 3, 4, 5, 6];
  return PATTERNS.map((_, i) => i);
}

function spawnObstacles() {
  let pool, idx;
  if (bossActive) {
    // hardest patterns during boss
    pool = [7, 8, 9];
    idx  = pool[Math.floor(Math.random() * pool.length)];
  } else {
    pool = availablePatterns();
    idx  = pool[Math.floor(Math.random() * pool.length)];
  }
  const pat  = PATTERNS[idx];
  const baseX = W + 50;
  for (const p of pat) {
    const def = PLANT_DEFS[p.t];
    obstacles.push({
      type: p.t,
      x: baseX + p.dx,
      y: GROUND_Y - def.h,
      w: def.w,
      h: def.h,
    });
  }
}

// â”€â”€â”€ Level Editor State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const EDITOR_SLOTS = 18;
const SLOT_W = 44;
const PLANT_TYPES = ['mushroom','sunflower','cactus','bush','tallgrass'];
const PLANT_ICONS = ['ğŸ„','ğŸŒ»','ğŸŒµ','ğŸŒ¿','ğŸŒ¾'];
let editorSlots   = Array(EDITOR_SLOTS).fill(null); // null or plant type string
let editorSelected = 'mushroom';
let editorCopied  = false;
let editorCopiedTimer = 0;
let levelObstacles = null; // if non-null, use these instead of random spawn
let levelMode      = false; // true when playing a custom level

// â”€â”€â”€ Particles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnDeathParticles() {
  for (let i = 0; i < 20; i++) {
    const a = Math.random() * Math.PI * 2;
    const sp = 2 + Math.random() * 5;
    particles.push({
      x: bat.x + BAT_W / 2, y: bat.y + BAT_H / 2,
      vx: Math.cos(a) * sp, vy: Math.sin(a) * sp - 2,
      life: 1, dec: 0.02 + Math.random() * 0.018,
      r: 3 + Math.random() * 4,
      ang: Math.random() * Math.PI * 2, rot: (Math.random() - 0.5) * 0.2,
    });
  }
}

// â”€â”€â”€ Night progress â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function night() { return clamp(elapsed / 120, 0, 1); }

// â”€â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function onInput(e) {
  if (scene === 'start') { initAudio(); startGame(); return; }
  if (scene === 'dead')  { initAudio(); startGame(); return; }
  if (scene === 'play')  { doJump(); return; }
}

document.addEventListener('keydown', e => {
  if (e.code === 'Space') {
    e.preventDefault();
    onInput(e);
  }
  if (e.code === 'KeyE' && scene === 'start') {
    enterEditor();
  }
  if (e.code === 'Escape' && scene === 'editor') {
    scene = 'start';
  }
});

C.addEventListener('click', e => {
  if (scene === 'editor') {
    handleEditorClick(e);
    return;
  }
  if (scene === 'start') {
    // check if editor button was clicked
    const rect = C.getBoundingClientRect();
    const scaleX = W / rect.width;
    const scaleY = H / rect.height;
    const mx = (e.clientX - rect.left) * scaleX;
    const my = (e.clientY - rect.top) * scaleY;
    // Editor button region approx: centered around (W/2, H/2 + 115)
    if (mx > W/2 - 100 && mx < W/2 + 100 && my > H/2 + 98 && my < H/2 + 135) {
      enterEditor();
      return;
    }
  }
  onInput(e);
});

C.addEventListener('touchstart', e => {
  e.preventDefault();
  if (scene === 'editor') return; // handle separately
  onInput(e);
}, { passive: false });

// â”€â”€â”€ Lifecycle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startGame() {
  scene = 'play';
  score = 0; elapsed = 0; speed = 1.0; frame = 0; startMs = performance.now();
  obstacles = []; particles = [];
  spawnTimer = 0;
  shakeFrames = shakeX = shakeY = 0;
  scorePopScale = 1; scorePopFrames = 0;
  bat.y = BAT_FOOT_Y - BAT_H;
  bat.vy = 0; bat.grounded = true; bat.jumpsLeft = 2;
  bat.wx = bat.wy = 1; bat.flashFrames = 0;
  bat.legPhase = 0; bat.wingPhase = 0;

  // Ghost
  ghostRecord = [];
  ghostFrame  = 0;
  loadGhost();

  // Boss
  bossActive = false; bossTimer = 0;
  bossesTriggered = new Set();

  // Rhythm
  beatPulse = 0; jumpRating = null; beatTimes = [];
  if (audioCtx) {
    nextBeatTime = audioCtx.currentTime + 0.1;
    beatNumber = 0;
  }

  // Lightning
  lightningFlash = 0;
  nextLightning  = elapsed + 15 + Math.random() * 10;

  // Level mode
  if (levelObstacles) {
    levelMode = true;
    // Place level obstacles at spaced positions starting far right
    obstacles = levelObstacles.map((o, i) => {
      const def = PLANT_DEFS[o.type];
      return {
        type: o.type,
        x: W + 100 + o.slot * 90,
        y: GROUND_Y - def.h,
        w: def.w, h: def.h,
      };
    });
    // sort by x
    obstacles.sort((a,b) => a.x - b.x);
  } else {
    levelMode = false;
  }
}

function doJump() {
  if (bat.jumpsLeft <= 0) return;
  bat.vy = bat.jumpsLeft === 2 ? JUMP_VY : JUMP2_VY;
  bat.grounded = false;
  bat.jumpsLeft--;
  bat.wx = 0.75; bat.wy = 1.35;
  checkJumpRhythm();
}

function killBat() {
  bat.flashFrames = 14;
  scene = 'dead';
  shakeFrames = 24;
  spawnDeathParticles();
  if (score > hiScore) {
    hiScore = score;
    localStorage.setItem('batfarm_hi', hiScore.toString());
    saveGhost();
  }
  if (levelMode) {
    // return to editor after death in level test
    levelObstacles = null;
    levelMode = false;
  }
}

// â”€â”€â”€ Speed â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function calcSpeed(t) {
  return clamp(1.0 + t / 55, 1.0, 3.0);
}

// â”€â”€â”€ Update â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function update() {
  frame++;
  if (scene !== 'play') {
    // Update particles even on dead screen
    for (const p of particles) {
      p.x += p.vx; p.y += p.vy; p.vy += 0.15;
      p.life -= p.dec; p.ang += p.rot;
    }
    particles = particles.filter(p => p.life > 0);
    return;
  }

  elapsed = (performance.now() - startMs) / 1000;
  speed   = calcSpeed(elapsed);

  // Ghost recording (every 5 frames)
  if (frame % 5 === 0) {
    ghostRecord.push(bat.y);
  }

  // Ghost playback index
  const ghostIdx = Math.floor(frame / 5);

  // Boss triggering
  for (const bt of BOSS_TIMES) {
    if (!bossesTriggered.has(bt) && elapsed >= bt) {
      bossesTriggered.add(bt);
      bossActive = true;
      bossTimer  = 0;
    }
  }
  if (bossActive) {
    bossTimer += 1/60;
    if (bossTimer >= BOSS_DURATION) {
      bossActive = false;
      bossTimer  = 0;
    }
  }
  bossPulse = (bossPulse + 0.1) % (Math.PI * 2);

  // Storm lightning
  if (elapsed > 120) {
    if (elapsed >= nextLightning) {
      lightningFlash = 4;
      nextLightning  = elapsed + 15 + Math.random() * 10;
    }
    if (lightningFlash > 0) lightningFlash--;
  }

  // Rhythm scheduler
  runBeatScheduler();
  if (beatPulse > 0) beatPulse--;

  // Jump rating float
  if (jumpRating) {
    jumpRating.life--;
    jumpRating.y -= 0.8;
    if (jumpRating.life <= 0) jumpRating = null;
  }

  // Bat physics
  if (!bat.grounded) {
    bat.vy = clamp(bat.vy + GRAVITY, -30, 18);
    bat.y += bat.vy;
    if (bat.y >= BAT_FOOT_Y - BAT_H) {
      bat.y = BAT_FOOT_Y - BAT_H;
      bat.vy = 0;
      bat.grounded = true;
      bat.jumpsLeft = 2;
      bat.wy = 0.6; bat.wx = 1.4;
    }
  }

  bat.wx += (1 - bat.wx) * 0.15;
  bat.wy += (1 - bat.wy) * 0.15;
  if (bat.flashFrames > 0) bat.flashFrames--;

  if (bat.grounded) bat.legPhase += 0.25 * speed;
  bat.wingPhase += bat.grounded ? 0.06 : 0.28;

  // Score
  score += speed * 0.14;
  const si = Math.floor(score);
  if (si > 0 && si % 300 === 0 && Math.abs(score - si) < 0.16) {
    scorePopScale = 1.5; scorePopFrames = 22;
  }
  if (scorePopFrames > 0) { scorePopFrames--; scorePopScale = lerp(scorePopScale, 1, 0.12); }
  else scorePopScale = 1;

  // Move obstacles
  const pxPerFrame = speed * 4.5;
  for (const o of obstacles) o.x -= pxPerFrame;
  obstacles = obstacles.filter(o => o.x + o.w > -20);

  // Spawn (only in non-level mode)
  if (!levelMode) {
    const interval = bossActive ? 25 : Math.max(55, 160 / speed);
    spawnTimer++;
    if (spawnTimer >= interval) { spawnTimer = 0; spawnObstacles(); }
  } else {
    // In level mode, check if all obstacles are gone â†’ loop back to editor
    if (obstacles.length === 0) {
      scene = 'dead'; // show dead screen briefly
      levelObstacles = null;
      levelMode = false;
    }
  }

  // Collision
  const bx = bat.x + 6, by = bat.y + 4, bw = BAT_W - 12, bh = BAT_H - 4;
  for (const o of obstacles) {
    if (bx < o.x + o.w - 3 && bx + bw > o.x + 3 && by < o.y + o.h && by + bh > o.y) {
      killBat(); return;
    }
  }

  // Screen shake
  if (shakeFrames > 0) {
    shakeX = (Math.random() - 0.5) * 10;
    shakeY = (Math.random() - 0.5) * 10;
    shakeFrames--;
  } else { shakeX = shakeY = 0; }

  // Particles
  for (const p of particles) {
    p.x += p.vx; p.y += p.vy; p.vy += 0.15;
    p.life -= p.dec; p.ang += p.rot;
  }
  particles = particles.filter(p => p.life > 0);

  // Rain movement
  if (elapsed > 90) { // start rain as storm zone approaches
    const rainAlpha = clamp((elapsed - 90) / 30, 0, 1);
    for (const r of rainDrops) {
      r.x -= 2 * rainAlpha;
      r.y += r.speed * rainAlpha;
      if (r.y > H) { r.y = -20; r.x = Math.random() * W; }
      if (r.x < 0)  { r.x = W; }
    }
  }
}

// â”€â”€â”€ Draw â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function draw() {
  ctx.clearRect(0, 0, W, H);
  ctx.save();

  if (scene === 'editor') {
    drawEditor();
    ctx.restore();
    return;
  }

  ctx.translate(shakeX, shakeY);

  drawSky();
  drawStars();
  drawMoon();
  drawHorizonGlow();
  drawSilos();
  drawCropRows();
  drawGround();

  // Rain (storm zone)
  if (scene === 'play' || scene === 'dead') drawRain();

  for (const o of obstacles) drawPlant(o);

  // Ghost bat
  if (scene === 'play') drawGhost();

  if (scene !== 'start') drawBat();

  for (const p of particles) {
    ctx.save(); ctx.globalAlpha = p.life;
    ctx.translate(p.x, p.y); ctx.rotate(p.ang);
    ctx.fillStyle = '#4a3020';
    ctx.beginPath(); ctx.ellipse(0, 0, p.r, p.r * 0.4, 0, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
  }

  if (scene === 'play') {
    // Beat pulse ring
    drawBeatPulse();
    // Beat markers on ground
    drawBeatMarkers();
    // Boss overlay
    if (bossActive) drawBossOverlay();
    // Lightning flash
    if (lightningFlash > 0) {
      ctx.fillStyle = `rgba(255,255,255,${lightningFlash * 0.12})`;
      ctx.fillRect(0, 0, W, H);
    }
    drawHUD();
    // Jump rating
    if (jumpRating) {
      ctx.save();
      ctx.globalAlpha = jumpRating.life / 40;
      ctx.font = 'bold 20px Georgia, serif';
      ctx.textAlign = 'center';
      ctx.fillStyle = jumpRating.color;
      ctx.fillText(jumpRating.text, bat.x + BAT_W/2, jumpRating.y);
      ctx.restore();
    }
  }

  ctx.restore();

  if (scene === 'start') { drawStartBat(); drawStartScreen(); }
  else if (scene === 'dead') drawDeadScreen();
}

// â”€â”€â”€ Zone-themed Sky & World â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawSky() {
  const np = night();

  // Zone sky top colors
  // Zone 0 (farm): dark purpleâ†’violet night
  // Zone 1 (barn): warm amber interior tones (very dark warm)
  // Zone 2 (storm): dark grey-blue
  const top = zoneBlend(
    [lerpC(0x1a,0x04,np), lerpC(0x0a,0x02,np), lerpC(0x3e,0x10,np)],
    [lerpC(0x14,0x08,np), lerpC(0x08,0x04,np), lerpC(0x04,0x02,np)],
    [lerpC(0x0e,0x06,np), lerpC(0x12,0x08,np), lerpC(0x22,0x14,np)]
  );
  const mid = zoneBlend(
    [lerpC(0x55,0x0a,np), lerpC(0x1a,0x05,np), lerpC(0x70,0x22,np)],
    [lerpC(0x30,0x10,np), lerpC(0x18,0x08,np), lerpC(0x08,0x04,np)],
    [lerpC(0x18,0x0a,np), lerpC(0x1e,0x0c,np), lerpC(0x38,0x1a,np)]
  );
  const bot = zoneBlend(
    [lerpC(0xe0,0x08,np), lerpC(0x4a,0x05,np), lerpC(0x18,0x18,np)],
    [lerpC(0x80,0x10,np), lerpC(0x40,0x08,np), lerpC(0x08,0x04,np)],
    [lerpC(0x28,0x0a,np), lerpC(0x2e,0x10,np), lerpC(0x44,0x20,np)]
  );

  const g = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
  g.addColorStop(0,    `rgb(${top[0]},${top[1]},${top[2]})`);
  g.addColorStop(0.45, `rgb(${mid[0]},${mid[1]},${mid[2]})`);
  g.addColorStop(1,    `rgb(${bot[0]},${bot[1]},${bot[2]})`);
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, GROUND_Y);

  // Barn zone: add warm amber glow in sky
  const barnT = clamp((elapsed - 60) / 30, 0, 1) * clamp(1 - (elapsed - 100) / 20, 0, 1);
  if (barnT > 0) {
    const bg = ctx.createRadialGradient(W * 0.35, GROUND_Y, 0, W * 0.35, GROUND_Y, 200);
    bg.addColorStop(0, `rgba(255,140,0,${barnT * 0.25})`);
    bg.addColorStop(1, 'rgba(255,140,0,0)');
    ctx.fillStyle = bg;
    ctx.fillRect(0, 0, W, GROUND_Y);
  }
}

function drawRain() {
  if (elapsed <= 90) return;
  const rainAlpha = clamp((elapsed - 90) / 30, 0, 0.55);
  ctx.save();
  ctx.strokeStyle = `rgba(180,200,255,${rainAlpha * 0.6})`;
  ctx.lineWidth = 1;
  for (const r of rainDrops) {
    ctx.beginPath();
    ctx.moveTo(r.x, r.y);
    ctx.lineTo(r.x - 2, r.y + r.len);
    ctx.stroke();
  }
  ctx.restore();
}

function drawStars() {
  const np = night();
  if (np < 0.25) return;
  const stormT = clamp((elapsed - 120) / 30, 0, 1);
  const a = (np - 0.25) / 0.75 * (1 - stormT * 0.8);
  if (a <= 0) return;
  for (const s of stars) {
    s.tw += 0.028;
    ctx.save(); ctx.globalAlpha = (Math.sin(s.tw) * 0.3 + 0.7) * a;
    ctx.fillStyle = '#fffde8';
    ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
  }
}

function drawMoon() {
  const np = night();
  if (np < 0.45) return;
  const stormT = clamp((elapsed - 120) / 30, 0, 1);
  const a  = (np - 0.45) / 0.55 * (1 - stormT * 0.7);
  if (a <= 0) return;
  const mx = W * 0.76, my = H * 0.1 + (1 - a) * 90;
  ctx.save(); ctx.globalAlpha = a * 0.92;
  const gl = ctx.createRadialGradient(mx, my, 0, mx, my, 55);
  gl.addColorStop(0, 'rgba(255,255,200,0.28)');
  gl.addColorStop(1, 'rgba(255,255,200,0)');
  ctx.fillStyle = gl; ctx.beginPath(); ctx.arc(mx, my, 55, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#fff9d0'; ctx.beginPath(); ctx.arc(mx, my, 21, 0, Math.PI * 2); ctx.fill();
  ctx.restore();
}

function drawHorizonGlow() {
  const np = night();
  // Zone 0: warm orange glow
  // Zone 1: amber lantern glow
  // Zone 2: dim blue-grey glow
  const glowColor = zoneBlend([244,160,58],[255,140,0],[100,120,160]);
  const alphaFactor = zoneBlend([55,0,0],[70,0,0],[20,0,0])[0] / 100;

  if (np < 0.05) {
    const baseAlpha = (1 - np / 0.85) * 0.55 * (alphaFactor);
    const g = ctx.createLinearGradient(0, GROUND_Y - 90, 0, GROUND_Y);
    g.addColorStop(0, `rgba(${glowColor[0]},${glowColor[1]},${glowColor[2]},0)`);
    g.addColorStop(1, `rgba(${glowColor[0]},${glowColor[1]},${glowColor[2]},${baseAlpha})`);
    ctx.fillStyle = g; ctx.fillRect(0, GROUND_Y - 90, W, 90);
  }

  if (np <= 0.85) {
    const baseAlpha = (1 - np / 0.85) * 0.55;
    const gA = clamp(baseAlpha * (zoneBlend([1,0,0],[0.6,0,0],[0.2,0,0])[0]), 0, 1);
    const g = ctx.createLinearGradient(0, GROUND_Y - 90, 0, GROUND_Y);
    g.addColorStop(0, `rgba(${glowColor[0]},${glowColor[1]},${glowColor[2]},0)`);
    g.addColorStop(1, `rgba(${glowColor[0]},${glowColor[1]},${glowColor[2]},${gA})`);
    ctx.fillStyle = g; ctx.fillRect(0, GROUND_Y - 90, W, 90);
  }

  // Barn zone lantern glow near horizon
  const barnT = clamp((elapsed - 60) / 20, 0, 1) * clamp(1 - (elapsed - 110) / 20, 0, 1);
  if (barnT > 0) {
    const lg = ctx.createRadialGradient(W * 0.15, GROUND_Y - 10, 0, W * 0.15, GROUND_Y - 10, 80);
    lg.addColorStop(0, `rgba(255,160,0,${barnT * 0.4})`);
    lg.addColorStop(1, 'rgba(255,160,0,0)');
    ctx.fillStyle = lg;
    ctx.beginPath(); ctx.arc(W * 0.15, GROUND_Y - 10, 80, 0, Math.PI * 2); ctx.fill();
  }
}

function drawSilos() {
  const np = night();
  const col = `rgba(0,0,0,${0.68 + np * 0.28})`;
  for (const s of silos) {
    s.x -= 0.28 * speed;
    if (s.x < -120) s.x += W + 220;
    ctx.save(); ctx.fillStyle = col;
    if (s.kind === 'silo') {
      ctx.fillRect(s.x, GROUND_Y - s.h, 30, s.h);
      ctx.beginPath(); ctx.arc(s.x + 15, GROUND_Y - s.h, 15, Math.PI, 0); ctx.fill();
      ctx.fillRect(s.x + 38, GROUND_Y - s.h * 0.65, 20, s.h * 0.65);
    } else {
      ctx.fillRect(s.x + 10, GROUND_Y - s.h, 8, s.h * 0.42);
      ctx.beginPath(); ctx.arc(s.x + 14, GROUND_Y - s.h * 0.78, 22, 0, Math.PI * 2); ctx.fill();
    }
    ctx.restore();
  }
}

function drawCropRows() {
  const np = night();
  // Zone colors for crop band
  const band = zoneBlend(
    [lerpC(40,10,np), lerpC(88,30,np), lerpC(18,4,np)],
    [lerpC(55,20,np), lerpC(35,15,np), lerpC(5,2,np)],    // barn: dark wood
    [lerpC(20,8,np),  lerpC(25,10,np), lerpC(30,12,np)]    // storm: grey
  );
  ctx.fillStyle = `rgb(${band[0]},${band[1]},${band[2]})`;
  ctx.fillRect(0, GROUND_Y - 28, W, 28);

  const crop = zoneBlend(
    [lerpC(74,26,np), lerpC(122,58,np), lerpC(42,10,np)],
    [lerpC(88,40,np), lerpC(55,28,np),  lerpC(14,6,np)],   // barn: hay-ish
    [lerpC(40,16,np), lerpC(55,25,np),  lerpC(55,20,np)]    // storm: grey-green
  );
  ctx.fillStyle = `rgb(${crop[0]},${crop[1]},${crop[2]})`;

  for (const r of cropRows) {
    r.x -= 1.4 * speed;
    if (r.x < -75) r.x += cropRows.length * 70;
    for (let i = 0; i < 6; i++) {
      const cx = r.x + i * 13;
      ctx.beginPath(); ctx.ellipse(cx, GROUND_Y - 14 + Math.sin(cx * 0.3) * 3, 4, 8, 0, 0, Math.PI * 2); ctx.fill();
    }
  }

  // Barn zone: scatter hay wisps
  const barnT = clamp((elapsed - 60) / 20, 0, 1) * clamp(1 - (elapsed - 110) / 20, 0, 1);
  if (barnT > 0.1) {
    ctx.save();
    ctx.globalAlpha = barnT * 0.5;
    ctx.strokeStyle = '#c8a030';
    ctx.lineWidth = 1.5;
    for (let hi = 0; hi < 8; hi++) {
      const hx = ((frame * 0.8 + hi * 130) % (W + 60)) - 30;
      const hy = GROUND_Y - 10 - Math.sin(hi * 2.3) * 6;
      ctx.beginPath();
      ctx.moveTo(hx, hy);
      ctx.quadraticCurveTo(hx + 10, hy - 8, hx + 20, hy + 3);
      ctx.stroke();
    }
    ctx.restore();
  }
}

function drawGround() {
  const np = night();
  const gc = zoneBlend(
    [lerpC(107,55,np), lerpC(66,32,np), lerpC(38,16,np)],
    [lerpC(80,40,np),  lerpC(45,22,np), lerpC(18,8,np)],   // barn: darker wood-brown
    [lerpC(55,28,np),  lerpC(60,30,np), lerpC(62,30,np)]    // storm: grey
  );
  ctx.fillStyle = `rgb(${gc[0]},${gc[1]},${gc[2]})`;
  ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);
  ctx.strokeStyle = 'rgba(0,0,0,0.35)'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0, GROUND_Y); ctx.lineTo(W, GROUND_Y); ctx.stroke();
}

// â”€â”€â”€ Ghost Bat â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawGhost() {
  if (!ghostData || ghostData.length === 0) return;
  const idx = Math.floor(frame / 5);
  if (idx >= ghostData.length) return;
  const gy = ghostData[idx];

  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.translate(bat.x + BAT_W/2, gy + BAT_H/2);

  // Orange ghost silhouette - simplified flying pose
  ctx.fillStyle = '#ff8800';
  // wings
  const ws = 50, wd = 12;
  ctx.beginPath();
  ctx.moveTo(-3,-3);
  ctx.bezierCurveTo(-ws*0.38,-wd,-ws*0.82,wd*0.5,-ws/2,wd+2);
  ctx.bezierCurveTo(-ws*0.28,wd+8,-ws*0.08,5,-3,3);
  ctx.closePath(); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(3,-3);
  ctx.bezierCurveTo(ws*0.38,-wd,ws*0.82,wd*0.5,ws/2,wd+2);
  ctx.bezierCurveTo(ws*0.28,wd+8,ws*0.08,5,3,3);
  ctx.closePath(); ctx.fill();
  // body
  ctx.beginPath(); ctx.ellipse(0, 0, 14, 9, 0, 0, Math.PI*2); ctx.fill();
  // ears
  ctx.beginPath(); ctx.moveTo(-7,-7); ctx.lineTo(-12,-17); ctx.lineTo(-3,-9); ctx.fill();
  ctx.beginPath(); ctx.moveTo(7,-7);  ctx.lineTo(12,-17);  ctx.lineTo(3,-9);  ctx.fill();

  ctx.restore();

  // GHOST label
  ctx.save();
  ctx.globalAlpha = 0.5;
  ctx.font = 'bold 11px monospace';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#ff8800';
  ctx.fillText('GHOST', bat.x + BAT_W/2, gy - 22);
  ctx.restore();
}

// â”€â”€â”€ Boss Overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawBossOverlay() {
  // Red tint
  ctx.fillStyle = 'rgba(255,0,0,0.08)';
  ctx.fillRect(-shakeX, -shakeY, W, H);

  // Pulsing banner
  const pulse = Math.sin(bossPulse * 3) * 0.3 + 0.7;
  ctx.save();
  ctx.globalAlpha = pulse;
  ctx.fillStyle = 'rgba(180,0,0,0.75)';
  ctx.fillRect(W/2 - 170, 8, 340, 38);
  ctx.font = 'bold 22px Georgia, serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#ffeeee';
  ctx.shadowColor = '#ff0000';
  ctx.shadowBlur = 12;
  ctx.fillText('âš¡ BOSS WAVE âš¡', W/2, 27);
  ctx.restore();
}

// â”€â”€â”€ Rhythm Beat Visuals â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawBeatPulse() {
  if (beatPulse <= 0) return;
  const prog = 1 - beatPulse / 15;
  const r = prog * 120;
  const a = (1 - prog) * 0.5;
  ctx.save();
  ctx.globalAlpha = a;
  ctx.strokeStyle = '#f4a03a';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(0, GROUND_Y, r, Math.PI, 0);
  ctx.stroke();
  ctx.restore();
}

function drawBeatMarkers() {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const pxPerSec = speed * 4.5 * 60; // approximate pixels per second
  const beatWidthPx = (BEAT_MS / 1000) * pxPerSec;

  ctx.save();
  ctx.globalAlpha = 0.25;
  ctx.fillStyle = '#f4c060';
  // show next 3 beats as ground markers
  for (let i = 1; i <= 3; i++) {
    const secAhead = (nextBeatTime - now) + (i - 1) * BEAT_MS / 1000;
    const xPos = clamp(secAhead * pxPerSec * 0.4, 0, W);
    const pr = 3 + Math.sin(frame * 0.1 + i) * 1.5;
    ctx.beginPath();
    ctx.arc(xPos, GROUND_Y + 5, pr, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}

// â”€â”€â”€ Draw Plants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawPlant(o) {
  ctx.save();
  const bx = o.x, by = o.y, bw = o.w, bh = o.h;
  switch (o.type) {

    case 'mushroom': {
      ctx.fillStyle = '#d4b896';
      ctx.fillRect(bx + bw/2 - 5, by + bh*0.45, 10, bh*0.55);
      ctx.fillStyle = '#c0392b';
      ctx.beginPath(); ctx.ellipse(bx + bw/2, by + bh*0.45, bw/2, bh*0.55, 0, Math.PI, 0); ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      ctx.beginPath(); ctx.arc(bx + bw/2 - 5, by + bh*0.25, 4, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(bx + bw/2 + 5, by + bh*0.35, 3, 0, Math.PI*2); ctx.fill();
      break;
    }

    case 'sunflower': {
      ctx.strokeStyle = '#4a7a20'; ctx.lineWidth = 4;
      ctx.beginPath(); ctx.moveTo(bx + bw/2, GROUND_Y); ctx.lineTo(bx + bw/2, by + 22); ctx.stroke();
      ctx.fillStyle = '#4a7a20';
      ctx.beginPath(); ctx.ellipse(bx + bw/2 - 10, by + bh*0.55, 14, 7, -0.5, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#f4c020';
      for (let i = 0; i < 8; i++) {
        const a = (i / 8) * Math.PI * 2;
        ctx.beginPath(); ctx.ellipse(bx + bw/2 + Math.cos(a)*13, by + 14 + Math.sin(a)*13, 7, 4, a, 0, Math.PI*2); ctx.fill();
      }
      ctx.fillStyle = '#5a2800';
      ctx.beginPath(); ctx.arc(bx + bw/2, by + 14, 9, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#3a1800';
      ctx.beginPath(); ctx.arc(bx + bw/2, by + 14, 6, 0, Math.PI*2); ctx.fill();
      break;
    }

    case 'cactus': {
      ctx.fillStyle = '#3a8a30';
      ctx.beginPath();
      ctx.roundRect(bx + bw/2 - 7, by + 10, 14, bh - 10, 6);
      ctx.fill();
      ctx.beginPath();
      ctx.roundRect(bx, by + bh*0.35, bw/2 - 4, 10, 4);
      ctx.fill();
      ctx.beginPath();
      ctx.roundRect(bx, by + bh*0.18, 10, bh*0.35 - bh*0.18 + 10, 4);
      ctx.fill();
      ctx.beginPath();
      ctx.roundRect(bx + bw/2 + 4, by + bh*0.5, bw/2 - 4, 10, 4);
      ctx.fill();
      ctx.beginPath();
      ctx.roundRect(bx + bw - 10, by + bh*0.28, 10, bh*0.5 - bh*0.28 + 10, 4);
      ctx.fill();
      ctx.strokeStyle = '#c8e890'; ctx.lineWidth = 1.5;
      const spines = [[bx+bw/2-7,by+18],[bx+bw/2+7,by+26],[bx+bw/2-7,by+38],[bx+bw/2+7,by+50]];
      for (const [sx,sy] of spines) {
        ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(sx-6,sy-4); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(sx-6,sy+4); ctx.stroke();
      }
      break;
    }

    case 'bush': {
      const centers = [[0.15,0.35],[0.4,0.12],[0.65,0.22],[0.88,0.4],[0.5,0.08]];
      ctx.fillStyle = '#2e7a1a';
      for (const [fx,fy] of centers) {
        const r = bh * (0.38 + fy * 0.3);
        ctx.beginPath(); ctx.arc(bx + bw*fx, by + bh*fy + r*0.5, r, 0, Math.PI*2); ctx.fill();
      }
      ctx.fillStyle = '#3a8e22';
      for (const [fx,fy] of centers.slice(0,4)) {
        const r = bh * 0.28;
        ctx.beginPath(); ctx.arc(bx + bw*fx + 4, by + bh*fy + r*0.3, r, 0, Math.PI*2); ctx.fill();
      }
      ctx.fillStyle = '#cc2244';
      for (let i = 0; i < 5; i++) {
        ctx.beginPath(); ctx.arc(bx + 8 + i*10 + Math.sin(i)*4, by + bh*0.3 + Math.cos(i)*6, 3, 0, Math.PI*2); ctx.fill();
      }
      break;
    }

    case 'tallgrass': {
      const blades = [
        { ox:2,  lean:-0.2, w:4, col:'#4a8a20' },
        { ox:7,  lean: 0.15,w:5, col:'#3a7a18' },
        { ox:11, lean:-0.1, w:4, col:'#5a9a28' },
        { ox:15, lean: 0.25,w:3, col:'#4a8a20' },
      ];
      for (const b of blades) {
        const tx = bx + b.ox + Math.sin(frame*0.04 + b.lean*5)*3;
        ctx.fillStyle = b.col;
        ctx.beginPath();
        ctx.moveTo(tx, GROUND_Y);
        ctx.lineTo(tx - b.w/2, GROUND_Y);
        ctx.quadraticCurveTo(tx + b.lean*20, by + bh*0.5, tx + b.lean*30, by);
        ctx.quadraticCurveTo(tx + b.lean*20 + b.w, by + bh*0.5, tx + b.w/2, GROUND_Y);
        ctx.closePath(); ctx.fill();
        ctx.fillStyle = '#c8a840';
        ctx.beginPath(); ctx.ellipse(tx + b.lean*30, by, 3, 7, b.lean*0.5, 0, Math.PI*2); ctx.fill();
      }
      break;
    }
  }
  ctx.restore();
}

// â”€â”€â”€ Draw Bat â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawBat() {
  const np = night();
  ctx.save();
  ctx.translate(bat.x + BAT_W/2, bat.y + BAT_H/2);
  ctx.scale(bat.wx, bat.wy);

  const col = bat.flashFrames > 0 ? '#fff' : '#2e1e0c';

  if (bat.grounded) {
    const lp = bat.legPhase;
    ctx.fillStyle = col === '#fff' ? '#fff' : '#1e1208';
    ctx.beginPath(); ctx.ellipse(-10 + Math.sin(lp)*5, BAT_H/2 - 2, 3, 5, Math.sin(lp)*0.4, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(2  + Math.sin(lp+Math.PI)*5, BAT_H/2 - 2, 3, 5, Math.sin(lp+Math.PI)*0.4, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = col;
    ctx.beginPath();
    ctx.moveTo(-3, -4);
    ctx.bezierCurveTo(-20, -8, -26, 4, -18, 10);
    ctx.bezierCurveTo(-12, 14,  -6, 6,  -3, 4);
    ctx.closePath(); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(3, -4);
    ctx.bezierCurveTo(20, -8, 26, 4, 18, 10);
    ctx.bezierCurveTo(12, 14,  6, 6,  3, 4);
    ctx.closePath(); ctx.fill();
  } else {
    const wf = Math.sin(bat.wingPhase) * 0.5 + 0.5;
    const ws = 50, wd = 10 + wf * 14;
    ctx.fillStyle = col;
    ctx.beginPath();
    ctx.moveTo(-3, -3);
    ctx.bezierCurveTo(-ws*0.38, -wd, -ws*0.82, wd*wf, -ws/2, wd+2);
    ctx.bezierCurveTo(-ws*0.28, wd+8, -ws*0.08, 5, -3, 3);
    ctx.closePath(); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(3, -3);
    ctx.bezierCurveTo(ws*0.38, -wd, ws*0.82, wd*wf, ws/2, wd+2);
    ctx.bezierCurveTo(ws*0.28, wd+8, ws*0.08, 5, 3, 3);
    ctx.closePath(); ctx.fill();
  }

  ctx.fillStyle = bat.flashFrames > 0 ? '#fff' : '#1e1208';
  ctx.beginPath(); ctx.ellipse(0, 0, 14, 9, 0, 0, Math.PI*2); ctx.fill();

  ctx.fillStyle = bat.flashFrames > 0 ? '#fff' : '#16100a';
  ctx.beginPath(); ctx.moveTo(-7,-7); ctx.lineTo(-12,-17); ctx.lineTo(-3,-9); ctx.fill();
  ctx.beginPath(); ctx.moveTo(7,-7);  ctx.lineTo(12,-17);  ctx.lineTo(3,-9);  ctx.fill();

  const eyeGlow = np > 0.38 ? (np - 0.38) / 0.62 : 0;
  if (eyeGlow > 0) {
    for (const ex of [-5, 5]) {
      const eg = ctx.createRadialGradient(ex,-4,0, ex,-4,13);
      eg.addColorStop(0, `rgba(255,70,0,${eyeGlow*0.45})`);
      eg.addColorStop(1, 'rgba(255,70,0,0)');
      ctx.fillStyle = eg; ctx.beginPath(); ctx.arc(ex,-4,13,0,Math.PI*2); ctx.fill();
    }
  }
  ctx.fillStyle = eyeGlow > 0 ? `rgba(255,100,40,${0.7+eyeGlow*0.3})` : '#ffc870';
  const er = eyeGlow > 0 ? 3.8 : 2.8;
  ctx.beginPath(); ctx.arc(-5,-4,er,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(5,-4,er,0,Math.PI*2);  ctx.fill();

  ctx.restore();
}

// â”€â”€â”€ HUD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawHUD() {
  ctx.save();
  ctx.textBaseline = 'top'; ctx.shadowColor = 'rgba(0,0,0,0.6)'; ctx.shadowBlur = 8;

  ctx.font = `bold ${Math.round(28 * scorePopScale)}px Georgia, serif`;
  ctx.textAlign = 'center'; ctx.fillStyle = '#fff';
  ctx.fillText(Math.floor(score) + 'm', W/2, 14);

  ctx.font = '15px Georgia, serif'; ctx.textAlign = 'right';
  ctx.fillStyle = 'rgba(255,250,190,0.88)';
  ctx.fillText('BEST ' + Math.floor(hiScore) + 'm', W - 18, 14);

  ctx.font = '14px monospace'; ctx.textAlign = 'left';
  ctx.fillStyle = 'rgba(255,255,255,0.72)';
  ctx.fillText('Ã—' + speed.toFixed(1), 18, 14);

  for (let i = 0; i < 2; i++) {
    ctx.beginPath();
    ctx.arc(18 + i*18, 44, 5, 0, Math.PI*2);
    ctx.fillStyle = i < bat.jumpsLeft ? '#f4a03a' : 'rgba(255,255,255,0.2)';
    ctx.fill();
  }

  // Zone indicator
  const zoneNames = ['Farm','Barn','Storm'];
  const zoneIdx = elapsed < 60 ? 0 : elapsed < 120 ? 1 : 2;
  ctx.font = '12px monospace'; ctx.textAlign = 'left';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText(zoneNames[zoneIdx], 18, 58);

  ctx.restore();
}

// â”€â”€â”€ Screens â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawStartBat() {
  ctx.save(); ctx.translate(W/2, H * 0.38);
  ctx.fillStyle = 'rgba(30,18,8,0.8)';
  const ws = 64, wd = 14;
  ctx.beginPath();
  ctx.moveTo(-3,-3); ctx.bezierCurveTo(-ws*0.38,-wd,-ws*0.82,wd*0.5,-ws/2,wd+2);
  ctx.bezierCurveTo(-ws*0.28,wd+8,-ws*0.08,5,-3,3); ctx.closePath(); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(3,-3); ctx.bezierCurveTo(ws*0.38,-wd,ws*0.82,wd*0.5,ws/2,wd+2);
  ctx.bezierCurveTo(ws*0.28,wd+8,ws*0.08,5,3,3); ctx.closePath(); ctx.fill();
  ctx.fillStyle = '#16100a';
  ctx.beginPath(); ctx.ellipse(0,0,16,10,0,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawStartScreen() {
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.52)'; ctx.fillRect(0,0,W,H);
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

  ctx.shadowColor = '#ff6b35'; ctx.shadowBlur = 22;
  ctx.fillStyle = '#f4a03a'; ctx.font = 'bold 68px Georgia, serif';
  ctx.fillText('Bat Farm', W/2, H/2 - 62);

  ctx.shadowBlur = 0;
  ctx.fillStyle = '#e8d0a0'; ctx.font = '22px Georgia, serif';
  ctx.fillText('Jump over the plants!', W/2, H/2 - 18);

  ctx.fillStyle = '#ccc'; ctx.font = '17px Georgia, serif';
  ctx.fillText('Space / Click to jump  Â·  Double-tap to double-jump', W/2, H/2 + 18);

  if (Math.sin(frame * 0.065) > 0) {
    ctx.fillStyle = '#fff'; ctx.font = '20px Georgia, serif';
    ctx.fillText('Press Space or Click to Start', W/2, H/2 + 52);
  }
  if (hiScore > 0) {
    ctx.fillStyle = '#ffcc88'; ctx.font = '18px Georgia, serif';
    ctx.fillText('Best: ' + Math.floor(hiScore) + 'm', W/2, H/2 + 86);
  }

  // Level Editor button
  ctx.fillStyle = 'rgba(255,255,255,0.18)';
  ctx.beginPath(); ctx.roundRect(W/2 - 100, H/2 + 102, 200, 30, 8); ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 1;
  ctx.stroke();
  ctx.fillStyle = '#ddd'; ctx.font = '15px Georgia, serif';
  ctx.fillText('ğŸ“ Level Editor  (E)', W/2, H/2 + 117);

  ctx.restore();
}

function drawDeadScreen() {
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.62)'; ctx.fillRect(0,0,W,H);
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

  ctx.fillStyle = '#ff3333'; ctx.shadowColor = '#aa0000'; ctx.shadowBlur = 16;
  ctx.font = 'bold 54px Georgia, serif';
  ctx.fillText('You Crashed!', W/2, H/2 - 62);

  ctx.shadowBlur = 0;
  ctx.fillStyle = '#fff'; ctx.font = '28px Georgia, serif';
  ctx.fillText(Math.floor(score) + ' meters', W/2, H/2 - 12);

  if (score >= hiScore && score > 0) {
    ctx.fillStyle = '#ffcc00'; ctx.font = 'bold 22px Georgia, serif';
    ctx.fillText('New Record!', W/2, H/2 + 26);
  } else {
    ctx.fillStyle = '#aaa'; ctx.font = '18px Georgia, serif';
    ctx.fillText('Best: ' + Math.floor(hiScore) + 'm', W/2, H/2 + 26);
  }
  if (Math.sin(frame * 0.065) > 0) {
    ctx.fillStyle = '#fff'; ctx.font = '20px Georgia, serif';
    ctx.fillText('Press Space or Click to Restart', W/2, H/2 + 68);
  }
  ctx.restore();
}

// â”€â”€â”€ Level Editor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function enterEditor() {
  scene = 'editor';
  editorSlots = Array(EDITOR_SLOTS).fill(null);
  editorSelected = 'mushroom';
  editorCopied = false;
}

// Editor layout constants
const ED_TRACK_X = 140;
const ED_TRACK_Y = 260;
const ED_TRACK_H = 50;
const ED_PALETTE_X = 12;
const ED_PALETTE_Y = 200;
const ED_PALETTE_ITEM_H = 44;

function handleEditorClick(e) {
  const rect = C.getBoundingClientRect();
  const scaleX = W / rect.width;
  const scaleY = H / rect.height;
  const mx = (e.clientX - rect.left) * scaleX;
  const my = (e.clientY - rect.top) * scaleY;

  // Back button: top-left
  if (mx > 14 && mx < 90 && my > 14 && my < 44) {
    scene = 'start';
    return;
  }

  // Palette items
  for (let i = 0; i < PLANT_TYPES.length; i++) {
    const py = ED_PALETTE_Y + i * ED_PALETTE_ITEM_H;
    if (mx > ED_PALETTE_X && mx < ED_PALETTE_X + 115 && my > py && my < py + 38) {
      editorSelected = PLANT_TYPES[i];
      return;
    }
  }

  // Track slots
  for (let s = 0; s < EDITOR_SLOTS; s++) {
    const sx = ED_TRACK_X + s * SLOT_W;
    if (mx > sx && mx < sx + SLOT_W - 2 && my > ED_TRACK_Y && my < ED_TRACK_Y + ED_TRACK_H) {
      if (editorSlots[s] === editorSelected) {
        editorSlots[s] = null; // remove
      } else {
        editorSlots[s] = editorSelected;
      }
      return;
    }
  }

  // Test button
  if (mx > ED_TRACK_X && mx < ED_TRACK_X + 90 && my > ED_TRACK_Y + 80 && my < ED_TRACK_Y + 115) {
    testLevel();
    return;
  }

  // Share button
  if (mx > ED_TRACK_X + 100 && mx < ED_TRACK_X + 210 && my > ED_TRACK_Y + 80 && my < ED_TRACK_Y + 115) {
    shareLevel();
    return;
  }
}

function testLevel() {
  const placed = [];
  for (let s = 0; s < EDITOR_SLOTS; s++) {
    if (editorSlots[s]) {
      placed.push({ slot: s, type: editorSlots[s] });
    }
  }
  if (placed.length === 0) return;
  levelObstacles = placed;
  initAudio();
  startGame();
}

function shareLevel() {
  const data = [];
  for (let s = 0; s < EDITOR_SLOTS; s++) {
    if (editorSlots[s]) data.push({ slot: s, type: editorSlots[s] });
  }
  const encoded = btoa(JSON.stringify(data));
  const url = window.location.href.split('#')[0] + '#level=' + encoded;
  window.history.replaceState(null, '', '#level=' + encoded);
  navigator.clipboard.writeText(url).then(() => {
    editorCopied = true;
    editorCopiedTimer = 120;
  }).catch(() => {
    editorCopied = true;
    editorCopiedTimer = 120;
  });
}

function drawEditor() {
  // Background
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, W, H);

  // Title
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#f4a03a';
  ctx.font = 'bold 34px Georgia, serif';
  ctx.shadowColor = '#ff6b35';
  ctx.shadowBlur = 12;
  ctx.fillText('Level Editor', W/2, 40);
  ctx.shadowBlur = 0;

  // Back button
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.beginPath(); ctx.roundRect(14, 14, 76, 28, 6); ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 1; ctx.stroke();
  ctx.fillStyle = '#ccc'; ctx.font = '14px Georgia, serif';
  ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
  ctx.fillText('â† Back', 24, 28);

  // Instructions
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.font = '13px Georgia, serif';
  ctx.textAlign = 'center';
  ctx.fillText('Select a plant, then click a slot to place it. Click again to remove.', W/2, 80);

  // â”€â”€ Plant Palette â”€â”€
  ctx.fillStyle = 'rgba(255,255,255,0.07)';
  ctx.beginPath(); ctx.roundRect(ED_PALETTE_X, ED_PALETTE_Y - 10, 120, PLANT_TYPES.length * ED_PALETTE_ITEM_H + 20, 10); ctx.fill();

  ctx.font = '12px monospace'; ctx.textAlign = 'left';
  ctx.fillStyle = 'rgba(255,255,255,0.5)';
  ctx.fillText('PLANTS', ED_PALETTE_X + 8, ED_PALETTE_Y - 2);

  for (let i = 0; i < PLANT_TYPES.length; i++) {
    const py = ED_PALETTE_Y + i * ED_PALETTE_ITEM_H;
    const isSelected = editorSelected === PLANT_TYPES[i];

    ctx.fillStyle = isSelected ? 'rgba(244,160,58,0.35)' : 'rgba(255,255,255,0.06)';
    ctx.beginPath(); ctx.roundRect(ED_PALETTE_X + 4, py + 2, 112, 36, 6); ctx.fill();

    if (isSelected) {
      ctx.strokeStyle = '#f4a03a'; ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.roundRect(ED_PALETTE_X + 4, py + 2, 112, 36, 6); ctx.stroke();
    }

    ctx.font = '20px serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.fillText(PLANT_ICONS[i], ED_PALETTE_X + 12, py + 20);

    ctx.font = '12px Georgia, serif';
    ctx.fillStyle = isSelected ? '#f4c060' : '#bbb';
    ctx.fillText(PLANT_TYPES[i], ED_PALETTE_X + 40, py + 20);
  }

  // â”€â”€ Track â”€â”€
  const trackW = EDITOR_SLOTS * SLOT_W;
  // Ground line
  ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(ED_TRACK_X - 10, ED_TRACK_Y + ED_TRACK_H);
  ctx.lineTo(ED_TRACK_X + trackW + 10, ED_TRACK_Y + ED_TRACK_H);
  ctx.stroke();

  // Slots
  for (let s = 0; s < EDITOR_SLOTS; s++) {
    const sx = ED_TRACK_X + s * SLOT_W;
    const type = editorSlots[s];

    ctx.fillStyle = type ? 'rgba(244,160,58,0.15)' : 'rgba(255,255,255,0.05)';
    ctx.strokeStyle = type ? '#f4a03a' : 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.rect(sx + 1, ED_TRACK_Y, SLOT_W - 2, ED_TRACK_H); ctx.fill(); ctx.stroke();

    // Slot number
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.font = '9px monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(s + 1, sx + SLOT_W/2, ED_TRACK_Y + 2);

    // Plant icon if placed
    if (type) {
      const idx = PLANT_TYPES.indexOf(type);
      ctx.font = '20px serif';
      ctx.textBaseline = 'bottom';
      ctx.fillText(PLANT_ICONS[idx], sx + SLOT_W/2, ED_TRACK_Y + ED_TRACK_H - 2);
    }
  }

  // â”€â”€ Buttons row â”€â”€
  const btnY = ED_TRACK_Y + 80;

  // Test button
  ctx.fillStyle = 'rgba(80,180,80,0.3)';
  ctx.beginPath(); ctx.roundRect(ED_TRACK_X, btnY, 90, 32, 8); ctx.fill();
  ctx.strokeStyle = '#66cc66'; ctx.lineWidth = 1.5; ctx.stroke();
  ctx.fillStyle = '#aaffaa'; ctx.font = 'bold 14px Georgia, serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText('â–¶ Test', ED_TRACK_X + 45, btnY + 16);

  // Share button
  ctx.fillStyle = 'rgba(80,120,220,0.3)';
  ctx.beginPath(); ctx.roundRect(ED_TRACK_X + 100, btnY, 110, 32, 8); ctx.fill();
  ctx.strokeStyle = '#6688ff'; ctx.lineWidth = 1.5; ctx.stroke();
  ctx.fillStyle = '#aabbff'; ctx.font = 'bold 14px Georgia, serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText('ğŸ”— Share', ED_TRACK_X + 155, btnY + 16);

  // Copied feedback
  if (editorCopied) {
    editorCopiedTimer--;
    ctx.fillStyle = '#44ff88';
    ctx.font = 'bold 13px monospace';
    ctx.textAlign = 'left';
    ctx.fillText('Copied!', ED_TRACK_X + 220, btnY + 16);
    if (editorCopiedTimer <= 0) { editorCopied = false; }
  }

  // Preview section
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.font = '12px monospace';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  ctx.fillText('PREVIEW', ED_TRACK_X, ED_TRACK_Y - 22);

  // Mini preview of placed plants as silhouettes above slots
  for (let s = 0; s < EDITOR_SLOTS; s++) {
    if (!editorSlots[s]) continue;
    const type = editorSlots[s];
    const def = PLANT_DEFS[type];
    const sx = ED_TRACK_X + s * SLOT_W + SLOT_W/2;
    const scale = Math.min((ED_TRACK_H - 4) / def.h, (SLOT_W - 4) / def.w);
    const ph = def.h * scale;
    const by2 = ED_TRACK_Y - 4;
    const drawObj = {
      type, x: sx - (def.w * scale)/2, y: by2 - ph, w: def.w * scale, h: ph
    };
    ctx.save();
    ctx.globalAlpha = 0.7;
    drawPlant(drawObj);
    ctx.restore();
  }

  // Hint
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.font = '11px monospace';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  ctx.fillText('Press E or click â† Back to return to menu', W/2, H - 12);
}

// â”€â”€â”€ Load level from URL hash â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function checkURLLevel() {
  const hash = window.location.hash;
  if (!hash.startsWith('#level=')) return;
  try {
    const encoded = hash.slice(7);
    const data = JSON.parse(atob(encoded));
    // Load into editor slots too
    editorSlots = Array(EDITOR_SLOTS).fill(null);
    for (const item of data) {
      if (item.slot >= 0 && item.slot < EDITOR_SLOTS && PLANT_TYPES.includes(item.type)) {
        editorSlots[item.slot] = item.type;
      }
    }
    levelObstacles = data.filter(d => PLANT_TYPES.includes(d.type));
    if (levelObstacles.length > 0) {
      initAudio();
      startGame();
    }
  } catch(e) {
    console.warn('Failed to load level from URL', e);
  }
}
checkURLLevel();

// â”€â”€â”€ Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function loop() { update(); draw(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>
