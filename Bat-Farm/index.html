<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Bat Farm — Endless Runner</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0614;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }
    canvas {
      display: block;
      cursor: pointer;
      image-rendering: pixelated;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
// =====================================================================
//  BAT FARM — Endless Runner
//  Single-file HTML5 Canvas game · No build tools
// =====================================================================

const C = document.getElementById('c');
const ctx = C.getContext('2d');

const W = 900, H = 500;
C.width = W; C.height = H;

// Responsive scale
function resize() {
  const s = Math.min(window.innerWidth / W, window.innerHeight / H);
  C.style.width  = (W * s) + 'px';
  C.style.height = (H * s) + 'px';
}
window.addEventListener('resize', resize);
resize();

// ─── Constants ───────────────────────────────────────────────────────
const GROUND_Y   = H - 70;
const GRAVITY    = 0.44;
const FLAP_VY    = -8.8;
const TERM_VY    = 11;
const BAT_X      = 150;
const SPAWN_BASE = 140; // frames between chunk spawns at 1× speed

// ─── State ───────────────────────────────────────────────────────────
let scene = 'start'; // 'start' | 'play' | 'dead'
let score, hiScore, elapsed, speed, frame, startTime;
let obstacles, particles, spawnTimer;
let shakeFrames, shakeX, shakeY;
let scorePopScale, scorePopFrames;

hiScore = +localStorage.getItem('batfarm_hi') || 0;

// ─── Bat ─────────────────────────────────────────────────────────────
const bat = {
  x: BAT_X, y: H / 2, vy: 0,
  alive: true,
  wx: 1, wy: 1,       // squash/stretch scale
  wingPhase: 0,
  flashFrames: 0,
  trail: [],
};

// ─── Parallax Layers ──────────────────────────────────────────────────
let silos, cropRows, stars;

function initWorld() {
  silos = [];
  for (let i = 0; i < 6; i++) {
    silos.push({
      x: i * 180 + Math.random() * 60,
      kind: Math.random() < 0.55 ? 'silo' : 'tree',
      h: 55 + Math.random() * 45,
    });
  }
  cropRows = [];
  for (let i = 0; i < 14; i++) cropRows.push({ x: i * 70 });

  stars = [];
  for (let i = 0; i < 90; i++) {
    stars.push({
      x: Math.random() * W,
      y: Math.random() * GROUND_Y * 0.65,
      r: Math.random() * 1.4 + 0.3,
      tw: Math.random() * Math.PI * 2,
    });
  }
}
initWorld();

// ─── Input ────────────────────────────────────────────────────────────
function onInput() {
  if (scene === 'start') startGame();
  else if (scene === 'play') doFlap();
  else if (scene === 'dead') startGame();
}
document.addEventListener('keydown', e => { if (e.code === 'Space') { e.preventDefault(); onInput(); } });
C.addEventListener('click', onInput);
C.addEventListener('touchstart', e => { e.preventDefault(); onInput(); }, { passive: false });

// ─── Game lifecycle ───────────────────────────────────────────────────
function startGame() {
  scene      = 'play';
  score      = 0;
  elapsed    = 0;
  speed      = 1.0;
  frame      = 0;
  spawnTimer = 0;
  obstacles  = [];
  particles  = [];
  shakeFrames = shakeX = shakeY = 0;
  scorePopScale = 1; scorePopFrames = 0;
  startTime  = performance.now();
  bat.y      = H / 2;
  bat.vy     = 0;
  bat.alive  = true;
  bat.wx = bat.wy = 1;
  bat.flashFrames = 0;
  bat.trail  = [];
}

function doFlap() {
  if (!bat.alive) return;
  bat.vy  = FLAP_VY;
  bat.wx  = 0.78;
  bat.wy  = 1.32;
  bat.trail.push({ x: bat.x, y: bat.y, a: 0.45 });
}

function killBat() {
  bat.alive      = false;
  bat.flashFrames = 12;
  scene           = 'dead';
  shakeFrames     = 22;
  spawnDeathParticles();
  if (score > hiScore) {
    hiScore = score;
    localStorage.setItem('batfarm_hi', hiScore.toString());
  }
}

// ─── Chunks ──────────────────────────────────────────────────────────
// Each chunk: array of { kind, dx, yAir? }
// dx = x offset from chunk origin
// yAir = y position for mid-air obstacles (optional)
const CHUNKS = [
  // 0 Single fence
  [{ k:'fence', dx:0 }],
  // 1 Fence gap run
  [{ k:'fence', dx:0 }, { k:'fence', dx:115 }, { k:'fence', dx:230 }],
  // 2 Low-and-High
  [{ k:'hay', dx:0 }, { k:'spray', dx:40, yAir: GROUND_Y - 155 }],
  // 3 Scarecrow Alley
  [{ k:'scarecrow', dx:0 }, { k:'scarecrow', dx:155 }],
  // 4 Power Line
  [{ k:'powerline', dx:0 }],
  // 5 Owl Ambush
  [{ k:'owl', dx:0 }, { k:'fence', dx:210 }],
  // 6 Night Firefly Zone
  [{ k:'fireflies', dx:0, yAir: GROUND_Y - 230 }],
  // 7 Tight Squeeze
  [{ k:'hay', dx:0 }, { k:'powerline_low', dx:0 }],
  // 8 Triple Fence Sprint
  [{ k:'fence', dx:0 }, { k:'fence', dx:82 }, { k:'fence', dx:164 }],
  // 9 Farm Gauntlet (late game)
  [{ k:'scarecrow', dx:0 }, { k:'owl', dx:130 }, { k:'fence', dx:310 }],
];

function availableChunks() {
  const t = elapsed;
  let idxs = t < 30 ? [0,1]
           : t < 60 ? [0,1,2,3,4,5]
           : [0,1,2,3,4,5,7,8,9];
  if (elapsed >= 60) idxs.push(6); // night only
  return idxs;
}

function spawnChunk() {
  const pool = availableChunks();
  const idx  = pool[Math.floor(Math.random() * pool.length)];
  const base = W + 60;
  for (const d of CHUNKS[idx]) {
    const o = makeObs(d.k, base + d.dx, d.yAir);
    if (o) obstacles.push(o);
  }
}

function makeObs(kind, x, yAir) {
  switch (kind) {
    case 'fence':
      return { k:'fence', x, y: GROUND_Y - 58, w:18, h:58, active:true };
    case 'hay':
      return { k:'hay', x, y: GROUND_Y - 40, w:54, h:40, active:true };
    case 'scarecrow':
      return { k:'scarecrow', x, y: GROUND_Y - 90, w:22, h:90, active:true };
    case 'spray': {
      const ey = yAir || GROUND_Y - 155;
      return { k:'spray', x, y: ey, w:80, h:40, active:true, life:1, pts: mkSprayPts() };
    }
    case 'powerline': {
      const ph = 78 + Math.random() * 40;
      return { k:'powerline', x, w:270, poleH: ph, active:true };
    }
    case 'powerline_low': {
      const ph = 100 + Math.random() * 20;
      return { k:'powerline', x, w:270, poleH: ph, active:true };
    }
    case 'owl':
      return { k:'owl', x, y: H * 0.32, w:42, h:34, vy:0, phase: Math.random()*Math.PI*2, active:true };
    case 'fireflies': {
      const fy = yAir || GROUND_Y - 230;
      return { k:'fireflies', x, y: fy, w:130, h:85, ffs: mkFireflies(), active:true };
    }
    default: return null;
  }
}

function mkSprayPts() {
  return Array.from({length:18}, () => ({
    ox: Math.random()*76, oy: Math.random()*28-14,
    r: Math.random()*9+4, ph: Math.random()*Math.PI*2,
  }));
}
function mkFireflies() {
  return Array.from({length:8}, () => ({
    ox: Math.random()*100, oy: Math.random()*60-30,
    ph: Math.random()*Math.PI*2, sp: 0.035+Math.random()*0.03,
  }));
}

// ─── Hitboxes ─────────────────────────────────────────────────────────
function hitbox(o) {
  switch (o.k) {
    case 'fence':     return [o.x+2, o.y,   o.w-4, o.h];
    case 'hay':       return [o.x+5, o.y+5, o.w-10, o.h-5];
    case 'scarecrow': return [o.x+3, o.y+8, o.w-6, o.h-8];
    case 'spray':     return [o.x+8, o.y-12, 65, 26];
    case 'powerline': {
      const wireY = GROUND_Y - o.poleH + 4;
      return [o.x, wireY-3, o.w, 7];
    }
    case 'owl':       return [o.x+9, o.y+7, o.w-18, o.h-14];
    case 'fireflies': return [o.x+18, o.y-18, o.w-36, 34];
    default:          return [o.x, o.y, o.w||20, o.h||20];
  }
}

function overlap(ax,ay,aw,ah, bx,by,bw,bh) {
  return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
}

// ─── Particles ────────────────────────────────────────────────────────
function spawnDeathParticles() {
  for (let i = 0; i < 22; i++) {
    const a = Math.random()*Math.PI*2;
    const sp = 2 + Math.random()*4.5;
    particles.push({
      x: bat.x, y: bat.y,
      vx: Math.cos(a)*sp, vy: Math.sin(a)*sp - 2.5,
      life: 1, dec: 0.018+Math.random()*0.02,
      r: 3+Math.random()*4, ang: Math.random()*Math.PI*2,
      rot: (Math.random()-0.5)*0.18,
    });
  }
}

// ─── Update ───────────────────────────────────────────────────────────
function update() {
  frame++;
  if (scene !== 'play') return;

  elapsed = (performance.now() - startTime) / 1000;

  // Speed ramp
  if      (elapsed < 30)  speed = 1.0;
  else if (elapsed < 60)  speed = lerp(1.0, 1.2, (elapsed-30)/30);
  else if (elapsed < 120) speed = lerp(1.2, 1.5, (elapsed-60)/60);
  else if (elapsed < 180) speed = lerp(1.5, 1.8, (elapsed-120)/60);
  else                    speed = clamp(lerp(1.8, 2.5, (elapsed-180)/120), 1.8, 2.5);

  // Bat physics
  bat.vy = clamp(bat.vy + GRAVITY, -30, TERM_VY);
  bat.y += bat.vy;
  bat.wx += (1 - bat.wx) * 0.14;
  bat.wy += (1 - bat.wy) * 0.14;
  if (bat.vy > 5) { bat.wx = lerp(bat.wx, 0.72, 0.08); bat.wy = lerp(bat.wy, 1.38, 0.08); }
  if (bat.flashFrames > 0) bat.flashFrames--;

  // Score
  score += speed * 0.12;
  const si = Math.floor(score);
  if (si > 0 && si % 500 === 0 && Math.abs(score - si) < 0.15) {
    scorePopScale = 1.55; scorePopFrames = 22;
  }
  if (scorePopFrames > 0) { scorePopFrames--; scorePopScale = lerp(scorePopScale, 1, 0.12); }
  else scorePopScale = 1;

  // Move obstacles
  for (const o of obstacles) {
    if (o.k === 'owl') {
      o.phase += 0.038;
      o.y += Math.sin(o.phase) * 1.6;
      o.x -= speed * 5.5;
    } else {
      o.x -= speed * 4.2;
    }
  }
  obstacles = obstacles.filter(o => o.x > -350);

  // Spawn
  spawnTimer++;
  const interval = Math.max(65, SPAWN_BASE / speed);
  if (spawnTimer >= interval) { spawnTimer = 0; spawnChunk(); }

  // Collision
  const bx = bat.x - 11, by = bat.y - 9, bw = 22, bh = 18;
  for (const o of obstacles) {
    if (!o.active) continue;
    const [hx,hy,hw,hh] = hitbox(o);
    if (overlap(bx,by,bw,bh, hx,hy,hw,hh)) { killBat(); return; }
  }
  if (bat.y + 9 >= GROUND_Y || bat.y - 9 <= 0) { killBat(); return; }

  // Screenshake
  if (shakeFrames > 0) {
    shakeX = (Math.random()-0.5) * 9;
    shakeY = (Math.random()-0.5) * 9;
    shakeFrames--;
  } else { shakeX = shakeY = 0; }

  // Particles
  for (const p of particles) {
    p.x += p.vx; p.y += p.vy; p.vy += 0.14;
    p.life -= p.dec; p.ang += p.rot;
  }
  particles = particles.filter(p => p.life > 0);

  // Trail
  bat.trail = bat.trail.filter(t => t.a > 0);
  for (const t of bat.trail) { t.x -= 3; t.a -= 0.042; }
}

// ─── Night progress (0=sunset, 1=full night) ─────────────────────────
function night() { return clamp(elapsed / 120, 0, 1); }

// ─── Draw helpers ─────────────────────────────────────────────────────
function lerp(a,b,t) { return a+(b-a)*clamp(t,0,1); }
function clamp(v,lo,hi) { return v<lo?lo:v>hi?hi:v; }
function lerpCol(a,b,t) { // lerp int 0–255
  return Math.round(lerp(a,b,t));
}

// ─── Draw ─────────────────────────────────────────────────────────────
function draw() {
  ctx.clearRect(0, 0, W, H);
  ctx.save();
  ctx.translate(shakeX, shakeY);

  drawSky();
  drawStars();
  drawMoon();
  drawHorizonGlow();
  drawSilos();
  drawCropRows();
  drawGround();

  // Obstacles
  for (const o of obstacles) drawObs(o);

  // Trail
  for (const t of bat.trail) {
    ctx.save(); ctx.globalAlpha = t.a;
    ctx.fillStyle = '#3a2a1a';
    ctx.beginPath(); ctx.ellipse(t.x, t.y, 16, 7, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }

  if (scene !== 'start') drawBat();

  // Particles
  for (const p of particles) {
    ctx.save(); ctx.globalAlpha = p.life;
    ctx.translate(p.x, p.y); ctx.rotate(p.ang);
    ctx.fillStyle = '#4a3020';
    ctx.beginPath(); ctx.ellipse(0,0,p.r,p.r*0.38,0,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  if (scene === 'play') drawHUD();

  ctx.restore(); // end shake

  if (scene === 'start') { drawStartBat(); drawStartScreen(); }
  else if (scene === 'dead') drawDeadScreen();
}

// ─── Sky ──────────────────────────────────────────────────────────────
function drawSky() {
  const np = night();
  const r0 = lerpCol(0x1a,0x04,np), g0 = lerpCol(0x0a,0x02,np), b0 = lerpCol(0x3e,0x10,np);
  const r1 = lerpCol(0x55,0x0a,np), g1 = lerpCol(0x1a,0x05,np), b1 = lerpCol(0x70,0x22,np);
  const r2 = lerpCol(0xe0,0x08,np), g2 = lerpCol(0x4a,0x05,np), b2 = lerpCol(0x18,0x18,np);
  const g = ctx.createLinearGradient(0,0,0,GROUND_Y);
  g.addColorStop(0,   `rgb(${r0},${g0},${b0})`);
  g.addColorStop(0.45,`rgb(${r1},${g1},${b1})`);
  g.addColorStop(1,   `rgb(${r2},${g2},${b2})`);
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,GROUND_Y);
}

function drawStars() {
  const np = night();
  if (np < 0.25) return;
  const a = (np - 0.25) / 0.75;
  for (const s of stars) {
    s.tw += 0.028;
    const tw = (Math.sin(s.tw)*0.3+0.7)*a;
    ctx.save(); ctx.globalAlpha = tw;
    ctx.fillStyle = '#fffde8';
    ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

function drawMoon() {
  const np = night();
  if (np < 0.45) return;
  const a   = (np-0.45)/0.55;
  const my  = H*0.1 + (1-a)*90;
  const mx  = W*0.76;
  ctx.save(); ctx.globalAlpha = a*0.92;
  // Glow
  const gl = ctx.createRadialGradient(mx,my,0,mx,my,55);
  gl.addColorStop(0,'rgba(255,255,200,0.28)');
  gl.addColorStop(1,'rgba(255,255,200,0)');
  ctx.fillStyle = gl; ctx.beginPath(); ctx.arc(mx,my,55,0,Math.PI*2); ctx.fill();
  // Disc
  ctx.fillStyle = '#fff9d0';
  ctx.beginPath(); ctx.arc(mx,my,21,0,Math.PI*2); ctx.fill();
  // Moon field glow
  ctx.globalAlpha = a*0.07;
  const fg = ctx.createLinearGradient(mx-220,GROUND_Y,mx+220,H);
  fg.addColorStop(0,'rgba(255,255,200,0)');
  fg.addColorStop(0.5,'rgba(255,255,200,1)');
  fg.addColorStop(1,'rgba(255,255,200,0)');
  ctx.fillStyle = fg; ctx.fillRect(mx-220,GROUND_Y,440,H-GROUND_Y);
  ctx.restore();
}

function drawHorizonGlow() {
  const np = night();
  if (np > 0.85) return;
  const a = (1-np/0.85)*0.55;
  const g = ctx.createLinearGradient(0,GROUND_Y-90,0,GROUND_Y);
  g.addColorStop(0,'rgba(244,160,58,0)');
  g.addColorStop(1,`rgba(244,160,58,${a})`);
  ctx.fillStyle = g; ctx.fillRect(0,GROUND_Y-90,W,90);
}

function drawSilos() {
  const np = night();
  const col = `rgba(0,0,0,${0.68+np*0.28})`;
  for (const s of silos) {
    s.x -= 0.28 * speed;
    if (s.x < -110) s.x += W + 200;
    ctx.save(); ctx.fillStyle = col;
    if (s.kind === 'silo') {
      const sw=30;
      ctx.fillRect(s.x, GROUND_Y-s.h, sw, s.h);
      ctx.beginPath(); ctx.arc(s.x+sw/2, GROUND_Y-s.h, sw/2, Math.PI, 0); ctx.fill();
      ctx.fillRect(s.x+38, GROUND_Y-s.h*0.65, 20, s.h*0.65);
    } else {
      ctx.fillRect(s.x+10, GROUND_Y-s.h, 8, s.h*0.42);
      ctx.beginPath(); ctx.arc(s.x+14, GROUND_Y-s.h*0.78, 22, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }
}

function drawCropRows() {
  const np = night();
  const r1 = lerpCol(74,26,np), g1 = lerpCol(122,58,np), b1 = lerpCol(42,10,np);
  const r2 = lerpCol(40,10,np), g2 = lerpCol(88,30,np), b2 = lerpCol(18,4,np);
  ctx.fillStyle = `rgb(${r2},${g2},${b2})`;
  ctx.fillRect(0, GROUND_Y-32, W, 32);
  ctx.fillStyle = `rgb(${r1},${g1},${b1})`;
  for (const r of cropRows) {
    r.x -= 1.4 * speed;
    if (r.x < -75) r.x += cropRows.length * 70;
    for (let i = 0; i < 6; i++) {
      const cx = r.x + i*13;
      ctx.beginPath(); ctx.ellipse(cx, GROUND_Y-16+Math.sin(cx*0.3)*3, 4.5, 9, 0, 0, Math.PI*2); ctx.fill();
    }
  }
}

function drawGround() {
  const np = night();
  const r = lerpCol(107,55,np), g = lerpCol(66,32,np), b = lerpCol(38,16,np);
  ctx.fillStyle = `rgb(${r},${g},${b})`;
  ctx.fillRect(0, GROUND_Y, W, H-GROUND_Y);
  ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0,GROUND_Y); ctx.lineTo(W,GROUND_Y); ctx.stroke();
}

// ─── Draw Obstacles ───────────────────────────────────────────────────
function drawObs(o) {
  ctx.save();
  switch (o.k) {
    case 'fence': {
      ctx.fillStyle = '#8b5e2e';
      ctx.fillRect(o.x, o.y, o.w, o.h);
      ctx.fillStyle = '#6b4426';
      ctx.fillRect(o.x-6, o.y+12, o.w+12, 6);
      ctx.fillStyle = '#8b5e2e';
      ctx.beginPath(); ctx.moveTo(o.x+o.w/2, o.y-10); ctx.lineTo(o.x, o.y); ctx.lineTo(o.x+o.w, o.y); ctx.closePath(); ctx.fill();
      break;
    }
    case 'hay': {
      ctx.fillStyle = '#c8a850';
      ctx.beginPath(); ctx.ellipse(o.x+o.w/2, o.y+o.h/2, o.w/2, o.h/2, 0, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = '#a08030'; ctx.lineWidth = 2;
      for (let i=1; i<4; i++) {
        const hy = o.y + i*(o.h/4);
        const dx = Math.sqrt(Math.max(0,(o.h/2)**2 - (hy-(o.y+o.h/2))**2));
        if (dx > 0) {
          ctx.beginPath(); ctx.moveTo(o.x+o.w/2-dx+2, hy); ctx.lineTo(o.x+o.w/2+dx-2, hy); ctx.stroke();
        }
      }
      break;
    }
    case 'scarecrow': {
      ctx.fillStyle = '#7a5a30';
      ctx.fillRect(o.x+7, o.y, 8, o.h);
      ctx.fillRect(o.x-10, o.y+18, o.w+20, 7);
      ctx.fillStyle = '#e8a820';
      ctx.beginPath(); ctx.ellipse(o.x+11, o.y+12, 13, 11, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#1a1000';
      ctx.fillRect(o.x+5,o.y+9,5,3); ctx.fillRect(o.x+14,o.y+9,5,3);
      ctx.beginPath(); ctx.arc(o.x+11,o.y+16,4,0,Math.PI); ctx.fill();
      ctx.fillStyle = '#111';
      ctx.fillRect(o.x+3,o.y-5,16,4); ctx.fillRect(o.x+5,o.y-16,12,13);
      ctx.fillStyle = '#7a4020';
      ctx.fillRect(o.x-9,o.y+25,o.w+18, o.h-25);
      ctx.fillStyle='#5a3018'; ctx.fillRect(o.x-9,o.y+25,12,o.h-25); ctx.fillRect(o.x+o.w+9-12,o.y+25,12,o.h-25);
      break;
    }
    case 'spray': {
      for (const p of o.pts) {
        p.ph += 0.038;
        const px = o.x + p.ox + Math.sin(p.ph)*4.5;
        const py = o.y + p.oy + Math.cos(p.ph*0.75)*3;
        ctx.globalAlpha = (0.28+Math.sin(p.ph)*0.1)*o.life;
        ctx.fillStyle = '#b0e898';
        ctx.beginPath(); ctx.arc(px,py,p.r,0,Math.PI*2); ctx.fill();
      }
      ctx.globalAlpha = 1;
      break;
    }
    case 'powerline': {
      const wireY = GROUND_Y - o.poleH;
      ctx.fillStyle = '#5a4020';
      ctx.fillRect(o.x, wireY, 13, o.poleH);
      ctx.fillRect(o.x+o.w-13, wireY, 13, o.poleH);
      ctx.strokeStyle = '#111'; ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(o.x+13, wireY+5);
      ctx.quadraticCurveTo(o.x+o.w/2, wireY+22, o.x+o.w-13, wireY+5);
      ctx.stroke();
      ctx.fillStyle = '#c03015';
      ctx.fillRect(o.x+10,wireY+1,9,8); ctx.fillRect(o.x+o.w-18,wireY+1,9,8);
      break;
    }
    case 'owl': {
      ctx.fillStyle = '#7a5a38';
      ctx.beginPath(); ctx.ellipse(o.x+o.w/2, o.y+o.h/2, o.w/2, o.h/2, 0, 0, Math.PI*2); ctx.fill();
      // Wings
      ctx.fillStyle = '#5a4028';
      const wf = Math.sin(o.phase*2.8)*10;
      ctx.beginPath(); ctx.moveTo(o.x,o.y+o.h/2); ctx.lineTo(o.x-28,o.y+o.h/2+wf); ctx.lineTo(o.x,o.y+o.h); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(o.x+o.w,o.y+o.h/2); ctx.lineTo(o.x+o.w+28,o.y+o.h/2+wf); ctx.lineTo(o.x+o.w,o.y+o.h); ctx.closePath(); ctx.fill();
      // Eyes
      ctx.fillStyle = '#ffee00';
      ctx.beginPath(); ctx.arc(o.x+14,o.y+12,5.5,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(o.x+28,o.y+12,5.5,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#000';
      ctx.beginPath(); ctx.arc(o.x+14,o.y+12,2.5,0,Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(o.x+28,o.y+12,2.5,0,Math.PI*2); ctx.fill();
      ctx.fillStyle = '#e8a020';
      ctx.beginPath(); ctx.moveTo(o.x+19,o.y+17); ctx.lineTo(o.x+23,o.y+23); ctx.lineTo(o.x+18,o.y+23); ctx.closePath(); ctx.fill();
      break;
    }
    case 'fireflies': {
      for (const f of o.ffs) {
        f.ph += f.sp;
        const fx = o.x + f.ox + Math.sin(f.ph)*16;
        const fy = o.y + f.oy + Math.cos(f.ph*1.35)*13;
        const gl = ctx.createRadialGradient(fx,fy,0,fx,fy,13);
        gl.addColorStop(0,'rgba(170,255,90,0.85)');
        gl.addColorStop(1,'rgba(170,255,90,0)');
        ctx.fillStyle = gl;
        ctx.beginPath(); ctx.arc(fx,fy,13,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = '#deff88';
        ctx.beginPath(); ctx.arc(fx,fy,2.5,0,Math.PI*2); ctx.fill();
      }
      break;
    }
  }
  ctx.restore();
}

// ─── Draw Bat ─────────────────────────────────────────────────────────
function drawBat() {
  ctx.save();
  ctx.translate(bat.x, bat.y);
  ctx.scale(bat.wx, bat.wy);

  bat.wingPhase += 0.22;
  const wf  = Math.sin(bat.wingPhase)*0.5+0.5;
  const ws  = 48;
  const wd  = 9 + wf*13;
  const col = bat.flashFrames > 0 ? '#fff' : '#3a2a1a';
  ctx.fillStyle = col;

  // Left wing
  ctx.beginPath();
  ctx.moveTo(-3,-3);
  ctx.bezierCurveTo(-ws*0.38,-wd, -ws*0.82,wd*wf, -ws/2,wd+2);
  ctx.bezierCurveTo(-ws*0.28,wd+8, -ws*0.08, 5, -3, 3);
  ctx.closePath(); ctx.fill();

  // Right wing
  ctx.beginPath();
  ctx.moveTo(3,-3);
  ctx.bezierCurveTo(ws*0.38,-wd, ws*0.82,wd*wf, ws/2,wd+2);
  ctx.bezierCurveTo(ws*0.28,wd+8, ws*0.08, 5, 3, 3);
  ctx.closePath(); ctx.fill();

  // Body
  ctx.fillStyle = bat.flashFrames > 0 ? '#fff' : '#2a1808';
  ctx.beginPath(); ctx.ellipse(0,0,13,9,0,0,Math.PI*2); ctx.fill();

  // Ears
  ctx.fillStyle = bat.flashFrames > 0 ? '#fff' : '#1e1208';
  ctx.beginPath(); ctx.moveTo(-8,-7); ctx.lineTo(-13,-18); ctx.lineTo(-4,-9); ctx.fill();
  ctx.beginPath(); ctx.moveTo(8,-7);  ctx.lineTo(13,-18);  ctx.lineTo(4,-9);  ctx.fill();

  // Eyes
  const np = night();
  const eyeGlow = np > 0.38 ? (np-0.38)/0.62 : 0;
  if (eyeGlow > 0) {
    const er1 = ctx.createRadialGradient(-5,-4,0,-5,-4,14);
    er1.addColorStop(0,`rgba(255,70,0,${eyeGlow*0.45})`);
    er1.addColorStop(1,'rgba(255,70,0,0)');
    ctx.fillStyle = er1; ctx.beginPath(); ctx.arc(-5,-4,14,0,Math.PI*2); ctx.fill();
    const er2 = ctx.createRadialGradient(5,-4,0,5,-4,14);
    er2.addColorStop(0,`rgba(255,70,0,${eyeGlow*0.45})`);
    er2.addColorStop(1,'rgba(255,70,0,0)');
    ctx.fillStyle = er2; ctx.beginPath(); ctx.arc(5,-4,14,0,Math.PI*2); ctx.fill();
  }
  ctx.fillStyle = eyeGlow > 0 ? `rgba(255,100,40,${0.7+eyeGlow*0.3})` : '#ffc870';
  const er = eyeGlow > 0 ? 3.8 : 2.8;
  ctx.beginPath(); ctx.arc(-5,-4,er,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(5,-4,er,0,Math.PI*2);  ctx.fill();

  ctx.restore();
}

// ─── HUD ─────────────────────────────────────────────────────────────
function drawHUD() {
  ctx.save();
  ctx.textBaseline = 'top';
  ctx.shadowColor = 'rgba(0,0,0,0.6)'; ctx.shadowBlur = 8;

  // Score
  const sc = Math.floor(score);
  ctx.font = `bold ${Math.round(28*scorePopScale)}px Georgia, serif`;
  ctx.textAlign = 'center'; ctx.fillStyle = '#fff';
  ctx.fillText(sc + 'm', W/2, 14);

  // Hi score
  ctx.font = '15px Georgia, serif'; ctx.textAlign = 'right';
  ctx.fillStyle = 'rgba(255,250,190,0.88)';
  ctx.fillText('BEST ' + Math.floor(hiScore) + 'm', W-18, 14);

  // Speed
  ctx.font = '14px monospace'; ctx.textAlign = 'left';
  ctx.fillStyle = 'rgba(255,255,255,0.7)';
  ctx.fillText('×'+speed.toFixed(1), 18, 14);

  // Day/night icon
  const np = night();
  const ix = 50, iy = 52;
  if (np < 0.5) {
    ctx.fillStyle = '#ffcc00';
    ctx.beginPath(); ctx.arc(ix,iy,8,0,Math.PI*2); ctx.fill();
  } else {
    ctx.fillStyle = '#ffe9a0';
    ctx.beginPath(); ctx.arc(ix,iy,8,0,Math.PI*2); ctx.fill();
    const r0=lerpCol(0x1a,0x04,np),g0=lerpCol(0x0a,0x02,np),b0=lerpCol(0x3e,0x10,np);
    ctx.fillStyle = `rgb(${r0},${g0},${b0})`;
    ctx.beginPath(); ctx.arc(ix+5,iy-2,6,0,Math.PI*2); ctx.fill();
  }
  ctx.restore();
}

// ─── Screens ──────────────────────────────────────────────────────────
function drawStartBat() {
  ctx.save(); ctx.translate(W/2, H*0.38);
  ctx.fillStyle = 'rgba(40,22,8,0.75)';
  const ws=62, wf=0.5, wd=11+wf*13;
  ctx.beginPath();
  ctx.moveTo(-3,-3); ctx.bezierCurveTo(-ws*0.38,-wd,-ws*0.82,wd*wf,-ws/2,wd+2);
  ctx.bezierCurveTo(-ws*0.28,wd+8,-ws*0.08,5,-3,3); ctx.closePath(); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(3,-3); ctx.bezierCurveTo(ws*0.38,-wd,ws*0.82,wd*wf,ws/2,wd+2);
  ctx.bezierCurveTo(ws*0.28,wd+8,ws*0.08,5,3,3); ctx.closePath(); ctx.fill();
  ctx.fillStyle = '#1e1208';
  ctx.beginPath(); ctx.ellipse(0,0,15,10,0,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawStartScreen() {
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.52)';
  ctx.fillRect(0,0,W,H);

  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.shadowColor = '#ff6b35'; ctx.shadowBlur = 22;
  ctx.fillStyle = '#f4a03a';
  ctx.font = 'bold 68px Georgia, serif';
  ctx.fillText('Bat Farm', W/2, H/2 - 62);

  ctx.shadowBlur = 0;
  ctx.fillStyle = '#e8d0a0'; ctx.font = '22px Georgia, serif';
  ctx.fillText('An Endless Runner', W/2, H/2 - 18);

  const blink = Math.sin(frame*0.065) > 0;
  if (blink) {
    ctx.fillStyle = '#fff'; ctx.font = '20px Georgia, serif';
    ctx.fillText('Press Space or Click to Start', W/2, H/2 + 30);
  }
  if (hiScore > 0) {
    ctx.fillStyle = '#ffcc88'; ctx.font = '18px Georgia, serif';
    ctx.fillText('Best: ' + Math.floor(hiScore) + 'm', W/2, H/2 + 72);
  }
  ctx.restore();
}

function drawDeadScreen() {
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.62)'; ctx.fillRect(0,0,W,H);
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

  ctx.fillStyle = '#ff3333'; ctx.shadowColor = '#aa0000'; ctx.shadowBlur = 16;
  ctx.font = 'bold 54px Georgia, serif';
  ctx.fillText('You Crashed!', W/2, H/2 - 62);

  ctx.shadowBlur = 0;
  ctx.fillStyle = '#fff'; ctx.font = '28px Georgia, serif';
  ctx.fillText(Math.floor(score) + ' meters', W/2, H/2 - 12);

  if (score >= hiScore && score > 0) {
    ctx.fillStyle = '#ffcc00'; ctx.font = 'bold 22px Georgia, serif';
    ctx.fillText('New Record!', W/2, H/2 + 26);
  } else {
    ctx.fillStyle = '#aaa'; ctx.font = '18px Georgia, serif';
    ctx.fillText('Best: ' + Math.floor(hiScore) + 'm', W/2, H/2 + 26);
  }

  const blink = Math.sin(frame*0.065) > 0;
  if (blink) {
    ctx.fillStyle = '#fff'; ctx.font = '20px Georgia, serif';
    ctx.fillText('Press Space or Click to Restart', W/2, H/2 + 68);
  }
  ctx.restore();
}

// ─── Game Loop ────────────────────────────────────────────────────────
function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
