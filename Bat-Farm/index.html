<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Bat Farm — Endless Runner</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #0a0614;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      overflow: hidden;
    }
    canvas { display: block; cursor: pointer; }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
// =====================================================================
//  BAT FARM — Ground Runner
//  Bat scurries along the ground and jumps over plant obstacles
// =====================================================================

const C = document.getElementById('c');
const ctx = C.getContext('2d');
const W = 900, H = 500;
C.width = W; C.height = H;

function resize() {
  const s = Math.min(window.innerWidth / W, window.innerHeight / H);
  C.style.width  = (W * s) + 'px';
  C.style.height = (H * s) + 'px';
}
window.addEventListener('resize', resize);
resize();

// ─── Constants ───────────────────────────────────────────────────────
const GROUND_Y   = H - 80;       // top of ground surface
const GRAVITY    = 0.65;
const JUMP_VY    = -13.5;
const JUMP2_VY   = -11.0;        // double-jump (second flap)
const BAT_W      = 44;
const BAT_H      = 24;
const BAT_FOOT_Y = GROUND_Y;     // bat rests here (bottom of bat = GROUND_Y)

// ─── Helpers ─────────────────────────────────────────────────────────
function lerp(a, b, t) { return a + (b - a) * clamp(t, 0, 1); }
function clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; }
function lerpC(a, b, t) { return Math.round(lerp(a, b, t)); }

// ─── State ───────────────────────────────────────────────────────────
let scene = 'start';
let score = 0, hiScore = +localStorage.getItem('batfarm_hi') || 0;
let elapsed = 0, speed = 1.0, frame = 0, startMs = 0;
let obstacles = [], particles = [];
let spawnTimer = 0;
let shakeFrames = 0, shakeX = 0, shakeY = 0;
let scorePopScale = 1, scorePopFrames = 0;

// ─── Bat ─────────────────────────────────────────────────────────────
const bat = {
  x: 130,
  y: BAT_FOOT_Y - BAT_H,
  vy: 0,
  grounded: true,
  jumpsLeft: 2,          // bat gets a double-jump (second flap)
  wingPhase: 0,
  legPhase: 0,
  wx: 1, wy: 1,          // squash/stretch
  flashFrames: 0,
};

// ─── World layers ─────────────────────────────────────────────────────
let silos, cropRows, stars;
function initWorld() {
  silos = Array.from({length: 6}, (_, i) => ({
    x: i * 185 + Math.random() * 60,
    kind: Math.random() < 0.55 ? 'silo' : 'tree',
    h: 55 + Math.random() * 45,
  }));
  cropRows = Array.from({length: 14}, (_, i) => ({ x: i * 70 }));
  stars = Array.from({length: 90}, () => ({
    x: Math.random() * W, y: Math.random() * GROUND_Y * 0.6,
    r: Math.random() * 1.4 + 0.3, tw: Math.random() * Math.PI * 2,
  }));
}
initWorld();

// ─── Input ───────────────────────────────────────────────────────────
function onInput() {
  if (scene === 'start') { startGame(); return; }
  if (scene === 'dead')  { startGame(); return; }
  doJump();
}
document.addEventListener('keydown', e => {
  if (e.code === 'Space') { e.preventDefault(); onInput(); }
});
C.addEventListener('click', onInput);
C.addEventListener('touchstart', e => { e.preventDefault(); onInput(); }, { passive: false });

// ─── Lifecycle ───────────────────────────────────────────────────────
function startGame() {
  scene = 'play';
  score = 0; elapsed = 0; speed = 1.0; frame = 0; startMs = performance.now();
  obstacles = []; particles = [];
  spawnTimer = 0;
  shakeFrames = shakeX = shakeY = 0;
  scorePopScale = 1; scorePopFrames = 0;
  bat.y = BAT_FOOT_Y - BAT_H;
  bat.vy = 0; bat.grounded = true; bat.jumpsLeft = 2;
  bat.wx = bat.wy = 1; bat.flashFrames = 0;
  bat.legPhase = 0; bat.wingPhase = 0;
}

function doJump() {
  if (bat.jumpsLeft <= 0) return;
  bat.vy = bat.jumpsLeft === 2 ? JUMP_VY : JUMP2_VY;
  bat.grounded = false;
  bat.jumpsLeft--;
  bat.wx = 0.75; bat.wy = 1.35;  // squash on takeoff
}

function killBat() {
  bat.flashFrames = 14;
  scene = 'dead';
  shakeFrames = 24;
  spawnDeathParticles();
  if (score > hiScore) {
    hiScore = score;
    localStorage.setItem('batfarm_hi', hiScore.toString());
  }
}

// ─── Speed ───────────────────────────────────────────────────────────
// Smooth continuous ramp: starts at 1×, climbs to 3× by ~3 minutes
function calcSpeed(t) {
  return clamp(1.0 + t / 55, 1.0, 3.0);
}

// ─── Plants / Obstacles ──────────────────────────────────────────────
// Types: mushroom, sunflower, cactus, bush, tallgrass
// Spawned as single plants or small groups

const PLANT_DEFS = {
  mushroom:  { w: 28, h: 38 },
  sunflower: { w: 22, h: 72 },
  cactus:    { w: 26, h: 58 },
  bush:      { w: 58, h: 32 },
  tallgrass: { w: 18, h: 62 },
};

// Patterns: arrays of {type, dx} relative offsets
const PATTERNS = [
  // easy — single short
  [{ t:'mushroom', dx:0 }],
  [{ t:'bush',     dx:0 }],
  // medium — single tall
  [{ t:'cactus',   dx:0 }],
  [{ t:'tallgrass',dx:0 }],
  [{ t:'sunflower',dx:0 }],
  // medium — pairs
  [{ t:'mushroom', dx:0 }, { t:'mushroom', dx:38 }],
  [{ t:'cactus',   dx:0 }, { t:'bush',     dx:44 }],
  // harder — mixed height cluster
  [{ t:'mushroom', dx:0 }, { t:'sunflower',dx:44 }],
  [{ t:'bush',     dx:0 }, { t:'tallgrass',dx:70 }],
  // hardest — triple
  [{ t:'mushroom', dx:0 }, { t:'cactus',   dx:50 }, { t:'mushroom', dx:95 }],
];

function availablePatterns() {
  if (elapsed < 20) return [0, 1];
  if (elapsed < 45) return [0, 1, 2, 3, 4];
  if (elapsed < 80) return [0, 1, 2, 3, 4, 5, 6];
  return PATTERNS.map((_, i) => i);
}

function spawnObstacles() {
  const pool = availablePatterns();
  const idx  = pool[Math.floor(Math.random() * pool.length)];
  const pat  = PATTERNS[idx];
  const baseX = W + 50;
  for (const p of pat) {
    const def = PLANT_DEFS[p.t];
    obstacles.push({
      type: p.t,
      x: baseX + p.dx,
      y: GROUND_Y - def.h,
      w: def.w,
      h: def.h,
    });
  }
}

// ─── Particles ───────────────────────────────────────────────────────
function spawnDeathParticles() {
  for (let i = 0; i < 20; i++) {
    const a = Math.random() * Math.PI * 2;
    const sp = 2 + Math.random() * 5;
    particles.push({
      x: bat.x + BAT_W / 2, y: bat.y + BAT_H / 2,
      vx: Math.cos(a) * sp, vy: Math.sin(a) * sp - 2,
      life: 1, dec: 0.02 + Math.random() * 0.018,
      r: 3 + Math.random() * 4,
      ang: Math.random() * Math.PI * 2, rot: (Math.random() - 0.5) * 0.2,
    });
  }
}

// ─── Night progress ──────────────────────────────────────────────────
function night() { return clamp(elapsed / 120, 0, 1); }

// ─── Update ──────────────────────────────────────────────────────────
function update() {
  frame++;
  if (scene !== 'play') return;

  elapsed = (performance.now() - startMs) / 1000;
  speed   = calcSpeed(elapsed);

  // Bat physics
  if (!bat.grounded) {
    bat.vy = clamp(bat.vy + GRAVITY, -30, 18);
    bat.y += bat.vy;
    if (bat.y >= BAT_FOOT_Y - BAT_H) {
      bat.y = BAT_FOOT_Y - BAT_H;
      bat.vy = 0;
      bat.grounded = true;
      bat.jumpsLeft = 2;
      bat.wy = 0.6; bat.wx = 1.4;  // squash on landing
    }
  }

  // Squash/stretch recovery
  bat.wx += (1 - bat.wx) * 0.15;
  bat.wy += (1 - bat.wy) * 0.15;
  if (bat.flashFrames > 0) bat.flashFrames--;

  // Leg animation (only on ground)
  if (bat.grounded) bat.legPhase += 0.25 * speed;
  bat.wingPhase += bat.grounded ? 0.06 : 0.28;

  // Score
  score += speed * 0.14;
  const si = Math.floor(score);
  if (si > 0 && si % 300 === 0 && Math.abs(score - si) < 0.16) {
    scorePopScale = 1.5; scorePopFrames = 22;
  }
  if (scorePopFrames > 0) { scorePopFrames--; scorePopScale = lerp(scorePopScale, 1, 0.12); }
  else scorePopScale = 1;

  // Move obstacles
  const pxPerFrame = speed * 4.5;
  for (const o of obstacles) o.x -= pxPerFrame;
  obstacles = obstacles.filter(o => o.x + o.w > -20);

  // Spawn
  const interval = Math.max(55, 160 / speed);
  spawnTimer++;
  if (spawnTimer >= interval) { spawnTimer = 0; spawnObstacles(); }

  // Collision (tight box around bat body)
  const bx = bat.x + 6, by = bat.y + 4, bw = BAT_W - 12, bh = BAT_H - 4;
  for (const o of obstacles) {
    if (bx < o.x + o.w - 3 && bx + bw > o.x + 3 && by < o.y + o.h && by + bh > o.y) {
      killBat(); return;
    }
  }

  // Screenshake
  if (shakeFrames > 0) {
    shakeX = (Math.random() - 0.5) * 10;
    shakeY = (Math.random() - 0.5) * 10;
    shakeFrames--;
  } else { shakeX = shakeY = 0; }

  // Particles
  for (const p of particles) {
    p.x += p.vx; p.y += p.vy; p.vy += 0.15;
    p.life -= p.dec; p.ang += p.rot;
  }
  particles = particles.filter(p => p.life > 0);
}

// ─── Draw ─────────────────────────────────────────────────────────────
function draw() {
  ctx.clearRect(0, 0, W, H);
  ctx.save();
  ctx.translate(shakeX, shakeY);

  drawSky();
  drawStars();
  drawMoon();
  drawHorizonGlow();
  drawSilos();
  drawCropRows();
  drawGround();

  for (const o of obstacles) drawPlant(o);

  if (scene !== 'start') drawBat();

  for (const p of particles) {
    ctx.save(); ctx.globalAlpha = p.life;
    ctx.translate(p.x, p.y); ctx.rotate(p.ang);
    ctx.fillStyle = '#4a3020';
    ctx.beginPath(); ctx.ellipse(0, 0, p.r, p.r * 0.4, 0, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
  }

  if (scene === 'play') drawHUD();

  ctx.restore();

  if (scene === 'start') { drawStartBat(); drawStartScreen(); }
  else if (scene === 'dead') drawDeadScreen();
}

// ─── Sky & world drawing ──────────────────────────────────────────────
function drawSky() {
  const np = night();
  const g = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
  g.addColorStop(0,    `rgb(${lerpC(0x1a,0x04,np)},${lerpC(0x0a,0x02,np)},${lerpC(0x3e,0x10,np)})`);
  g.addColorStop(0.45, `rgb(${lerpC(0x55,0x0a,np)},${lerpC(0x1a,0x05,np)},${lerpC(0x70,0x22,np)})`);
  g.addColorStop(1,    `rgb(${lerpC(0xe0,0x08,np)},${lerpC(0x4a,0x05,np)},${lerpC(0x18,0x18,np)})`);
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, GROUND_Y);
}

function drawStars() {
  const np = night();
  if (np < 0.25) return;
  const a = (np - 0.25) / 0.75;
  for (const s of stars) {
    s.tw += 0.028;
    ctx.save(); ctx.globalAlpha = (Math.sin(s.tw) * 0.3 + 0.7) * a;
    ctx.fillStyle = '#fffde8';
    ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
  }
}

function drawMoon() {
  const np = night();
  if (np < 0.45) return;
  const a  = (np - 0.45) / 0.55;
  const mx = W * 0.76, my = H * 0.1 + (1 - a) * 90;
  ctx.save(); ctx.globalAlpha = a * 0.92;
  const gl = ctx.createRadialGradient(mx, my, 0, mx, my, 55);
  gl.addColorStop(0, 'rgba(255,255,200,0.28)');
  gl.addColorStop(1, 'rgba(255,255,200,0)');
  ctx.fillStyle = gl; ctx.beginPath(); ctx.arc(mx, my, 55, 0, Math.PI * 2); ctx.fill();
  ctx.fillStyle = '#fff9d0'; ctx.beginPath(); ctx.arc(mx, my, 21, 0, Math.PI * 2); ctx.fill();
  ctx.restore();
}

function drawHorizonGlow() {
  const np = night();
  if (np > 0.85) return;
  const a = (1 - np / 0.85) * 0.55;
  const g = ctx.createLinearGradient(0, GROUND_Y - 90, 0, GROUND_Y);
  g.addColorStop(0, 'rgba(244,160,58,0)');
  g.addColorStop(1, `rgba(244,160,58,${a})`);
  ctx.fillStyle = g; ctx.fillRect(0, GROUND_Y - 90, W, 90);
}

function drawSilos() {
  const np = night();
  const col = `rgba(0,0,0,${0.68 + np * 0.28})`;
  for (const s of silos) {
    s.x -= 0.28 * speed;
    if (s.x < -120) s.x += W + 220;
    ctx.save(); ctx.fillStyle = col;
    if (s.kind === 'silo') {
      ctx.fillRect(s.x, GROUND_Y - s.h, 30, s.h);
      ctx.beginPath(); ctx.arc(s.x + 15, GROUND_Y - s.h, 15, Math.PI, 0); ctx.fill();
      ctx.fillRect(s.x + 38, GROUND_Y - s.h * 0.65, 20, s.h * 0.65);
    } else {
      ctx.fillRect(s.x + 10, GROUND_Y - s.h, 8, s.h * 0.42);
      ctx.beginPath(); ctx.arc(s.x + 14, GROUND_Y - s.h * 0.78, 22, 0, Math.PI * 2); ctx.fill();
    }
    ctx.restore();
  }
}

function drawCropRows() {
  const np = night();
  const r2 = lerpC(40,10,np), g2 = lerpC(88,30,np), b2 = lerpC(18,4,np);
  ctx.fillStyle = `rgb(${r2},${g2},${b2})`;
  ctx.fillRect(0, GROUND_Y - 28, W, 28);
  const r1 = lerpC(74,26,np), g1 = lerpC(122,58,np), b1 = lerpC(42,10,np);
  ctx.fillStyle = `rgb(${r1},${g1},${b1})`;
  for (const r of cropRows) {
    r.x -= 1.4 * speed;
    if (r.x < -75) r.x += cropRows.length * 70;
    for (let i = 0; i < 6; i++) {
      const cx = r.x + i * 13;
      ctx.beginPath(); ctx.ellipse(cx, GROUND_Y - 14 + Math.sin(cx * 0.3) * 3, 4, 8, 0, 0, Math.PI * 2); ctx.fill();
    }
  }
}

function drawGround() {
  const np = night();
  ctx.fillStyle = `rgb(${lerpC(107,55,np)},${lerpC(66,32,np)},${lerpC(38,16,np)})`;
  ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);
  ctx.strokeStyle = 'rgba(0,0,0,0.35)'; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(0, GROUND_Y); ctx.lineTo(W, GROUND_Y); ctx.stroke();
}

// ─── Draw Plants ─────────────────────────────────────────────────────
function drawPlant(o) {
  ctx.save();
  const bx = o.x, by = o.y, bw = o.w, bh = o.h;
  switch (o.type) {

    case 'mushroom': {
      // stem
      ctx.fillStyle = '#d4b896';
      ctx.fillRect(bx + bw/2 - 5, by + bh*0.45, 10, bh*0.55);
      // cap
      ctx.fillStyle = '#c0392b';
      ctx.beginPath(); ctx.ellipse(bx + bw/2, by + bh*0.45, bw/2, bh*0.55, 0, Math.PI, 0); ctx.fill();
      // spots
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      ctx.beginPath(); ctx.arc(bx + bw/2 - 5, by + bh*0.25, 4, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.arc(bx + bw/2 + 5, by + bh*0.35, 3, 0, Math.PI*2); ctx.fill();
      break;
    }

    case 'sunflower': {
      // stem
      ctx.strokeStyle = '#4a7a20'; ctx.lineWidth = 4;
      ctx.beginPath(); ctx.moveTo(bx + bw/2, GROUND_Y); ctx.lineTo(bx + bw/2, by + 22); ctx.stroke();
      // leaf
      ctx.fillStyle = '#4a7a20';
      ctx.beginPath(); ctx.ellipse(bx + bw/2 - 10, by + bh*0.55, 14, 7, -0.5, 0, Math.PI*2); ctx.fill();
      // petals
      ctx.fillStyle = '#f4c020';
      for (let i = 0; i < 8; i++) {
        const a = (i / 8) * Math.PI * 2;
        ctx.beginPath(); ctx.ellipse(bx + bw/2 + Math.cos(a)*13, by + 14 + Math.sin(a)*13, 7, 4, a, 0, Math.PI*2); ctx.fill();
      }
      // centre
      ctx.fillStyle = '#5a2800';
      ctx.beginPath(); ctx.arc(bx + bw/2, by + 14, 9, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#3a1800';
      ctx.beginPath(); ctx.arc(bx + bw/2, by + 14, 6, 0, Math.PI*2); ctx.fill();
      break;
    }

    case 'cactus': {
      // main trunk
      ctx.fillStyle = '#3a8a30';
      ctx.beginPath();
      ctx.roundRect(bx + bw/2 - 7, by + 10, 14, bh - 10, 6);
      ctx.fill();
      // left arm
      ctx.beginPath();
      ctx.roundRect(bx, by + bh*0.35, bw/2 - 4, 10, 4);
      ctx.fill();
      ctx.beginPath();
      ctx.roundRect(bx, by + bh*0.18, 10, bh*0.35 - bh*0.18 + 10, 4);
      ctx.fill();
      // right arm
      ctx.beginPath();
      ctx.roundRect(bx + bw/2 + 4, by + bh*0.5, bw/2 - 4, 10, 4);
      ctx.fill();
      ctx.beginPath();
      ctx.roundRect(bx + bw - 10, by + bh*0.28, 10, bh*0.5 - bh*0.28 + 10, 4);
      ctx.fill();
      // spines
      ctx.strokeStyle = '#c8e890'; ctx.lineWidth = 1.5;
      const spines = [[bx+bw/2-7,by+18],[bx+bw/2+7,by+26],[bx+bw/2-7,by+38],[bx+bw/2+7,by+50]];
      for (const [sx,sy] of spines) {
        ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(sx-6,sy-4); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(sx-6,sy+4); ctx.stroke();
      }
      break;
    }

    case 'bush': {
      // several overlapping circles
      const centers = [[0.15,0.35],[0.4,0.12],[0.65,0.22],[0.88,0.4],[0.5,0.08]];
      ctx.fillStyle = '#2e7a1a';
      for (const [fx,fy] of centers) {
        const r = bh * (0.38 + fy * 0.3);
        ctx.beginPath(); ctx.arc(bx + bw*fx, by + bh*fy + r*0.5, r, 0, Math.PI*2); ctx.fill();
      }
      ctx.fillStyle = '#3a8e22';
      for (const [fx,fy] of centers.slice(0,4)) {
        const r = bh * 0.28;
        ctx.beginPath(); ctx.arc(bx + bw*fx + 4, by + bh*fy + r*0.3, r, 0, Math.PI*2); ctx.fill();
      }
      // berries
      ctx.fillStyle = '#cc2244';
      for (let i = 0; i < 5; i++) {
        ctx.beginPath(); ctx.arc(bx + 8 + i*10 + Math.sin(i)*4, by + bh*0.3 + Math.cos(i)*6, 3, 0, Math.PI*2); ctx.fill();
      }
      break;
    }

    case 'tallgrass': {
      // several swaying blades
      const blades = [
        { ox:2,  lean:-0.2, w:4, col:'#4a8a20' },
        { ox:7,  lean: 0.15,w:5, col:'#3a7a18' },
        { ox:11, lean:-0.1, w:4, col:'#5a9a28' },
        { ox:15, lean: 0.25,w:3, col:'#4a8a20' },
      ];
      for (const b of blades) {
        const tx = bx + b.ox + Math.sin(frame*0.04 + b.lean*5)*3;
        ctx.fillStyle = b.col;
        ctx.beginPath();
        ctx.moveTo(tx, GROUND_Y);
        ctx.lineTo(tx - b.w/2, GROUND_Y);
        ctx.quadraticCurveTo(tx + b.lean*20, by + bh*0.5, tx + b.lean*30, by);
        ctx.quadraticCurveTo(tx + b.lean*20 + b.w, by + bh*0.5, tx + b.w/2, GROUND_Y);
        ctx.closePath(); ctx.fill();
        // seed tip
        ctx.fillStyle = '#c8a840';
        ctx.beginPath(); ctx.ellipse(tx + b.lean*30, by, 3, 7, b.lean*0.5, 0, Math.PI*2); ctx.fill();
      }
      break;
    }
  }
  ctx.restore();
}

// ─── Draw Bat ─────────────────────────────────────────────────────────
function drawBat() {
  const np = night();
  ctx.save();
  ctx.translate(bat.x + BAT_W/2, bat.y + BAT_H/2);
  ctx.scale(bat.wx, bat.wy);

  const col = bat.flashFrames > 0 ? '#fff' : '#2e1e0c';

  if (bat.grounded) {
    // Walking: small scurrying legs
    const lp = bat.legPhase;
    ctx.fillStyle = col === '#fff' ? '#fff' : '#1e1208';
    // back legs
    ctx.beginPath(); ctx.ellipse(-10 + Math.sin(lp)*5, BAT_H/2 - 2, 3, 5, Math.sin(lp)*0.4, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(2  + Math.sin(lp+Math.PI)*5, BAT_H/2 - 2, 3, 5, Math.sin(lp+Math.PI)*0.4, 0, Math.PI*2); ctx.fill();
    // wings folded against body
    ctx.fillStyle = col;
    ctx.beginPath();
    ctx.moveTo(-3, -4);
    ctx.bezierCurveTo(-20, -8, -26, 4, -18, 10);
    ctx.bezierCurveTo(-12, 14,  -6, 6,  -3, 4);
    ctx.closePath(); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(3, -4);
    ctx.bezierCurveTo(20, -8, 26, 4, 18, 10);
    ctx.bezierCurveTo(12, 14,  6, 6,  3, 4);
    ctx.closePath(); ctx.fill();
  } else {
    // Flying: wings spread
    const wf = Math.sin(bat.wingPhase) * 0.5 + 0.5;
    const ws = 50, wd = 10 + wf * 14;
    ctx.fillStyle = col;
    ctx.beginPath();
    ctx.moveTo(-3, -3);
    ctx.bezierCurveTo(-ws*0.38, -wd, -ws*0.82, wd*wf, -ws/2, wd+2);
    ctx.bezierCurveTo(-ws*0.28, wd+8, -ws*0.08, 5, -3, 3);
    ctx.closePath(); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(3, -3);
    ctx.bezierCurveTo(ws*0.38, -wd, ws*0.82, wd*wf, ws/2, wd+2);
    ctx.bezierCurveTo(ws*0.28, wd+8, ws*0.08, 5, 3, 3);
    ctx.closePath(); ctx.fill();
  }

  // Body
  ctx.fillStyle = bat.flashFrames > 0 ? '#fff' : '#1e1208';
  ctx.beginPath(); ctx.ellipse(0, 0, 14, 9, 0, 0, Math.PI*2); ctx.fill();

  // Ears
  ctx.fillStyle = bat.flashFrames > 0 ? '#fff' : '#16100a';
  ctx.beginPath(); ctx.moveTo(-7,-7); ctx.lineTo(-12,-17); ctx.lineTo(-3,-9); ctx.fill();
  ctx.beginPath(); ctx.moveTo(7,-7);  ctx.lineTo(12,-17);  ctx.lineTo(3,-9);  ctx.fill();

  // Eyes
  const eyeGlow = np > 0.38 ? (np - 0.38) / 0.62 : 0;
  if (eyeGlow > 0) {
    for (const ex of [-5, 5]) {
      const eg = ctx.createRadialGradient(ex,-4,0, ex,-4,13);
      eg.addColorStop(0, `rgba(255,70,0,${eyeGlow*0.45})`);
      eg.addColorStop(1, 'rgba(255,70,0,0)');
      ctx.fillStyle = eg; ctx.beginPath(); ctx.arc(ex,-4,13,0,Math.PI*2); ctx.fill();
    }
  }
  ctx.fillStyle = eyeGlow > 0 ? `rgba(255,100,40,${0.7+eyeGlow*0.3})` : '#ffc870';
  const er = eyeGlow > 0 ? 3.8 : 2.8;
  ctx.beginPath(); ctx.arc(-5,-4,er,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(5,-4,er,0,Math.PI*2);  ctx.fill();

  ctx.restore();
}

// ─── HUD ──────────────────────────────────────────────────────────────
function drawHUD() {
  ctx.save();
  ctx.textBaseline = 'top'; ctx.shadowColor = 'rgba(0,0,0,0.6)'; ctx.shadowBlur = 8;

  ctx.font = `bold ${Math.round(28 * scorePopScale)}px Georgia, serif`;
  ctx.textAlign = 'center'; ctx.fillStyle = '#fff';
  ctx.fillText(Math.floor(score) + 'm', W/2, 14);

  ctx.font = '15px Georgia, serif'; ctx.textAlign = 'right';
  ctx.fillStyle = 'rgba(255,250,190,0.88)';
  ctx.fillText('BEST ' + Math.floor(hiScore) + 'm', W - 18, 14);

  ctx.font = '14px monospace'; ctx.textAlign = 'left';
  ctx.fillStyle = 'rgba(255,255,255,0.72)';
  ctx.fillText('×' + speed.toFixed(1), 18, 14);

  // Jump pip indicators
  for (let i = 0; i < 2; i++) {
    ctx.beginPath();
    ctx.arc(18 + i*18, 44, 5, 0, Math.PI*2);
    ctx.fillStyle = i < bat.jumpsLeft ? '#f4a03a' : 'rgba(255,255,255,0.2)';
    ctx.fill();
  }

  ctx.restore();
}

// ─── Screens ──────────────────────────────────────────────────────────
function drawStartBat() {
  ctx.save(); ctx.translate(W/2, H * 0.38);
  ctx.fillStyle = 'rgba(30,18,8,0.8)';
  const ws = 64, wd = 14;
  ctx.beginPath();
  ctx.moveTo(-3,-3); ctx.bezierCurveTo(-ws*0.38,-wd,-ws*0.82,wd*0.5,-ws/2,wd+2);
  ctx.bezierCurveTo(-ws*0.28,wd+8,-ws*0.08,5,-3,3); ctx.closePath(); ctx.fill();
  ctx.beginPath();
  ctx.moveTo(3,-3); ctx.bezierCurveTo(ws*0.38,-wd,ws*0.82,wd*0.5,ws/2,wd+2);
  ctx.bezierCurveTo(ws*0.28,wd+8,ws*0.08,5,3,3); ctx.closePath(); ctx.fill();
  ctx.fillStyle = '#16100a';
  ctx.beginPath(); ctx.ellipse(0,0,16,10,0,0,Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawStartScreen() {
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.52)'; ctx.fillRect(0,0,W,H);
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

  ctx.shadowColor = '#ff6b35'; ctx.shadowBlur = 22;
  ctx.fillStyle = '#f4a03a'; ctx.font = 'bold 68px Georgia, serif';
  ctx.fillText('Bat Farm', W/2, H/2 - 62);

  ctx.shadowBlur = 0;
  ctx.fillStyle = '#e8d0a0'; ctx.font = '22px Georgia, serif';
  ctx.fillText('Jump over the plants!', W/2, H/2 - 18);

  ctx.fillStyle = '#ccc'; ctx.font = '17px Georgia, serif';
  ctx.fillText('Space / Click to jump  ·  Double-tap to double-jump', W/2, H/2 + 18);

  if (Math.sin(frame * 0.065) > 0) {
    ctx.fillStyle = '#fff'; ctx.font = '20px Georgia, serif';
    ctx.fillText('Press Space or Click to Start', W/2, H/2 + 52);
  }
  if (hiScore > 0) {
    ctx.fillStyle = '#ffcc88'; ctx.font = '18px Georgia, serif';
    ctx.fillText('Best: ' + Math.floor(hiScore) + 'm', W/2, H/2 + 86);
  }
  ctx.restore();
}

function drawDeadScreen() {
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.62)'; ctx.fillRect(0,0,W,H);
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

  ctx.fillStyle = '#ff3333'; ctx.shadowColor = '#aa0000'; ctx.shadowBlur = 16;
  ctx.font = 'bold 54px Georgia, serif';
  ctx.fillText('You Crashed!', W/2, H/2 - 62);

  ctx.shadowBlur = 0;
  ctx.fillStyle = '#fff'; ctx.font = '28px Georgia, serif';
  ctx.fillText(Math.floor(score) + ' meters', W/2, H/2 - 12);

  if (score >= hiScore && score > 0) {
    ctx.fillStyle = '#ffcc00'; ctx.font = 'bold 22px Georgia, serif';
    ctx.fillText('New Record!', W/2, H/2 + 26);
  } else {
    ctx.fillStyle = '#aaa'; ctx.font = '18px Georgia, serif';
    ctx.fillText('Best: ' + Math.floor(hiScore) + 'm', W/2, H/2 + 26);
  }
  if (Math.sin(frame * 0.065) > 0) {
    ctx.fillStyle = '#fff'; ctx.font = '20px Georgia, serif';
    ctx.fillText('Press Space or Click to Restart', W/2, H/2 + 68);
  }
  ctx.restore();
}

// ─── Loop ─────────────────────────────────────────────────────────────
function loop() { update(); draw(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>
