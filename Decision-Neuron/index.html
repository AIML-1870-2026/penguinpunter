<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Decision Neuron: Is Using AI Worth It?</title>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{
  --bg:#0d0806;--surface:#1a120e;--surface2:#261a14;--border:#3d2a1f;
  --text:#f0ddd0;--text-dim:#9a7e6e;
  --flame:#ff4d00;--ember:#ff8c00;--ash:#8b7355;
  --smoke:#4a3f35;--charcoal:#2a2018;
  --burn-red:#cc2200;--burn-bright:#ff6622;
  --toxic:#88aa22;--soot:#3a3028;
  --gold:#ffaa00;
}
html{font-size:14px}
body{background:var(--bg);color:var(--text);font-family:'Segoe UI',system-ui,sans-serif;line-height:1.5;overflow-x:hidden;position:relative}
h1,h2,h3{font-weight:600}
a{color:var(--ember)}

/* Smoke background */
#smoke-bg{position:fixed;top:0;left:0;width:100%;height:100%;z-index:0;pointer-events:none}
.app{position:relative;z-index:1;max-width:1400px;margin:0 auto;padding:1rem}

/* Header */
header{text-align:center;padding:1.5rem 0 1rem}
header h1{font-size:1.7rem;background:linear-gradient(90deg,#ff4d00,#ff8c00,#ffcc00,#ff4d00);background-size:200% 100%;-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;animation:fireShift 4s ease-in-out infinite}
@keyframes fireShift{0%,100%{background-position:0% 50%}50%{background-position:100% 50%}}
header p{color:var(--text-dim);margin-top:.3rem;font-size:.95rem}
header .subtitle-emphasis{color:var(--burn-red);font-weight:600}

/* Tabs */
.tabs{display:flex;gap:.5rem;justify-content:center;margin-bottom:1rem;flex-wrap:wrap}
.tab{background:var(--surface);border:1px solid var(--border);color:var(--text-dim);padding:.5rem 1.2rem;border-radius:8px;cursor:pointer;transition:all .2s;font-size:.9rem}
.tab:hover{border-color:var(--ember);color:var(--text)}
.tab.active{background:var(--surface2);border-color:var(--flame);color:var(--flame);box-shadow:0 0 15px rgba(255,77,0,.2)}

.panel{display:none}
.panel.active{display:block}

/* Cards */
.card{background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:1.2rem;margin-bottom:1rem;box-shadow:inset 0 0 30px rgba(0,0,0,.3)}
.card h3{font-size:1rem;margin-bottom:.8rem;color:var(--ember)}

/* Neuron layout */
.neuron-layout{display:grid;grid-template-columns:280px 1fr 280px;gap:1rem;align-items:start}
@media(max-width:960px){.neuron-layout{grid-template-columns:1fr;}}

/* Sliders */
.slider-group{margin-bottom:1rem}
.slider-label{display:flex;justify-content:space-between;align-items:center;margin-bottom:.3rem;font-size:.85rem}
.slider-label .name{color:var(--text)}
.slider-label .value{color:var(--ember);font-weight:600;font-variant-numeric:tabular-nums}
.weight-badge{display:inline-block;background:var(--surface2);border:1px solid var(--border);border-radius:4px;padding:0 .4rem;font-size:.75rem;color:var(--gold);margin-left:.5rem}
.slider-desc{font-size:.75rem;color:var(--text-dim);margin-bottom:.2rem}
input[type=range]{-webkit-appearance:none;width:100%;height:6px;border-radius:3px;background:var(--charcoal);outline:none;cursor:pointer}
input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:16px;height:16px;border-radius:50%;background:var(--flame);cursor:pointer;box-shadow:0 0 10px rgba(255,77,0,.5)}
.bias-slider input[type=range]::-webkit-slider-thumb{background:var(--toxic);box-shadow:0 0 10px rgba(136,170,34,.5)}

/* Neuron SVG */
.neuron-viz{display:flex;justify-content:center;align-items:center;min-height:360px}
.neuron-viz svg text{font-family:'Segoe UI',system-ui,sans-serif}

/* Math panel */
.math-row{display:flex;justify-content:space-between;align-items:center;padding:.35rem 0;border-bottom:1px solid var(--border);font-size:.85rem;font-variant-numeric:tabular-nums}
.math-row:last-child{border-bottom:none}
.math-row .label{color:var(--text-dim)}
.math-row .val{font-weight:600}
.math-row .val.pos{color:var(--ember)}
.math-row .val.neg{color:var(--burn-red)}
.formula{background:var(--charcoal);border:1px solid var(--border);border-radius:8px;padding:.8rem;font-family:'Courier New',monospace;font-size:.85rem;margin-bottom:.8rem;text-align:center;color:var(--gold)}

/* Output display */
.output-display{text-align:center;padding:1rem;margin-top:.5rem}
.output-prob{font-size:2.5rem;font-weight:700;font-variant-numeric:tabular-nums;transition:color .3s}
.output-label{font-size:1rem;margin-top:.3rem;font-weight:500;transition:color .3s}

/* Bias bar */
.bias-bar{margin-top:.5rem}
.bias-bar .slider-label .value{color:var(--toxic)}

/* Decision Boundary */
.boundary-controls{display:flex;gap:1rem;margin-bottom:1rem;flex-wrap:wrap;align-items:center}
.boundary-controls label{font-size:.85rem;color:var(--text-dim)}
.boundary-controls select{background:var(--charcoal);border:1px solid var(--border);color:var(--text);padding:.3rem .5rem;border-radius:6px;font-size:.85rem}
.canvas-wrap{position:relative;display:flex;justify-content:center}
canvas{border-radius:8px;cursor:crosshair}

/* Training */
.training-controls{display:flex;gap:.5rem;flex-wrap:wrap;margin-bottom:1rem;align-items:center}
.btn{background:var(--charcoal);border:1px solid var(--border);color:var(--text);padding:.45rem 1rem;border-radius:8px;cursor:pointer;font-size:.85rem;transition:all .2s}
.btn:hover{border-color:var(--ember);color:var(--ember)}
.btn.primary{border-color:var(--ember);color:var(--ember)}
.btn.danger{border-color:var(--burn-red);color:var(--burn-red)}
.btn.yes-btn{border-color:var(--flame);color:var(--flame)}
.btn.yes-btn.active,.btn.no-btn.active{background:var(--surface);font-weight:700}
.btn.no-btn{border-color:var(--ash);color:var(--ash)}
.training-stats{display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:.5rem;margin-top:.8rem}
.stat-box{background:var(--charcoal);border:1px solid var(--border);border-radius:8px;padding:.5rem .7rem;text-align:center}
.stat-box .stat-label{font-size:.7rem;color:var(--text-dim);text-transform:uppercase;letter-spacing:.05em}
.stat-box .stat-val{font-size:1.1rem;font-weight:700;font-variant-numeric:tabular-nums;color:var(--gold)}
.lr-control{display:flex;align-items:center;gap:.4rem;font-size:.85rem;color:var(--text-dim)}
.lr-control input{width:60px;background:var(--charcoal);border:1px solid var(--border);color:var(--text);padding:.2rem .4rem;border-radius:4px;font-size:.85rem;text-align:center}

/* Sensitivity */
.sensitivity-chart{display:flex;justify-content:center}
.legend{display:flex;flex-wrap:wrap;gap:.8rem;justify-content:center;margin-top:.8rem}
.legend-item{display:flex;align-items:center;gap:.3rem;font-size:.8rem}
.legend-dot{width:10px;height:10px;border-radius:50%}

/* Influence bars */
.influence-bars{margin-top:1rem}
.inf-row{display:flex;align-items:center;gap:.5rem;margin-bottom:.5rem;font-size:.85rem}
.inf-label{width:140px;text-align:right;color:var(--text-dim)}
.inf-bar-wrap{flex:1;height:20px;background:var(--charcoal);border-radius:4px;overflow:hidden;position:relative}
.inf-bar{height:100%;border-radius:4px;transition:width .3s}
.inf-val{width:50px;font-variant-numeric:tabular-nums;font-weight:600}

/* Fire glow on body edges */
body::before{content:'';position:fixed;bottom:0;left:0;right:0;height:250px;background:linear-gradient(to top,rgba(255,50,0,.25),rgba(200,40,0,.1),transparent);pointer-events:none;z-index:0}
body::after{content:'';position:fixed;top:0;left:0;right:0;height:200px;background:linear-gradient(to bottom,rgba(40,30,20,.7),rgba(30,20,10,.3),transparent);pointer-events:none;z-index:0}
</style>
</head>
<body>
<canvas id="smoke-bg"></canvas>
<div class="app">
  <header>
    <h1>Is Using AI Worth It, Even Though It Is Extremely Damaging to the Environment?</h1>
    <p>An interactive single-neuron decision explorer — adjust inputs, visualize boundaries, train, and analyze</p>
  </header>

  <div class="tabs">
    <button class="tab active" data-tab="neuron">Neuron</button>
    <button class="tab" data-tab="boundary">Decision Boundary</button>
    <button class="tab" data-tab="training">Training Mode</button>
    <button class="tab" data-tab="sensitivity">Sensitivity</button>
  </div>

  <!-- PANEL 1: Interactive Neuron -->
  <div class="panel active" id="panel-neuron">
    <div class="neuron-layout">
      <div class="card" id="input-panel">
        <h3>Inputs</h3>
        <div id="sliders-container"></div>
      </div>
      <div class="card">
        <h3>Neuron Visualization</h3>
        <div class="neuron-viz" id="neuron-viz"></div>
        <div class="output-display">
          <div class="output-prob" id="output-prob">50.0%</div>
          <div class="output-label" id="output-label">Probably worth it</div>
        </div>
        <div class="bias-bar">
          <div class="slider-label">
            <span class="name">AI Optimism (Bias)</span>
            <span class="value" id="bias-val">+0.50</span>
          </div>
          <div class="bias-slider">
            <input type="range" id="bias-slider" min="-3" max="3" step="0.05" value="0.5">
          </div>
        </div>
      </div>
      <div class="card" id="math-panel">
        <h3>Math Breakdown</h3>
        <div class="formula">z = &Sigma;(x<sub>i</sub> &middot; w<sub>i</sub>) + b</div>
        <div class="formula">&sigma;(z) = 1 / (1 + e<sup>-z</sup>)</div>
        <div id="math-breakdown"></div>
      </div>
    </div>
  </div>

  <!-- PANEL 2: Decision Boundary -->
  <div class="panel" id="panel-boundary">
    <div class="card">
      <h3>Decision Boundary Visualizer</h3>
      <div class="boundary-controls">
        <label>X-Axis: <select id="axis-x"></select></label>
        <label>Y-Axis: <select id="axis-y"></select></label>
        <span style="color:var(--text-dim);font-size:.8rem">Non-selected inputs use slider values</span>
      </div>
      <div class="canvas-wrap">
        <canvas id="boundary-canvas" width="500" height="500"></canvas>
      </div>
    </div>
  </div>

  <!-- PANEL 3: Training Mode -->
  <div class="panel" id="panel-training">
    <div class="card">
      <h3>Training Mode</h3>
      <div class="training-controls">
        <button class="btn yes-btn active" id="label-yes">Worth It (Yes)</button>
        <button class="btn no-btn" id="label-no">Not Worth It (No)</button>
        <span style="width:1rem"></span>
        <button class="btn primary" id="btn-step">Step</button>
        <button class="btn primary" id="btn-train">Train (50 steps)</button>
        <button class="btn danger" id="btn-reset">Reset</button>
        <div class="lr-control">
          <label>LR:</label>
          <input type="number" id="lr-input" value="0.1" min="0.001" max="2" step="0.01">
        </div>
      </div>
      <p style="font-size:.8rem;color:var(--text-dim);margin-bottom:.8rem">Click the heatmap to add training points. The neuron will learn from your examples.</p>
      <div class="boundary-controls">
        <label>X-Axis: <select id="train-axis-x"></select></label>
        <label>Y-Axis: <select id="train-axis-y"></select></label>
      </div>
      <div class="canvas-wrap">
        <canvas id="training-canvas" width="500" height="500"></canvas>
      </div>
      <div class="training-stats" id="training-stats"></div>
    </div>
  </div>

  <!-- PANEL 4: Sensitivity -->
  <div class="panel" id="panel-sensitivity">
    <div class="card">
      <h3>Sensitivity Analysis — Input Sweep</h3>
      <div class="sensitivity-chart">
        <canvas id="sensitivity-canvas" width="600" height="350"></canvas>
      </div>
      <div class="legend" id="sensitivity-legend"></div>
    </div>
    <div class="card">
      <h3>Input Influence Ranking</h3>
      <div class="influence-bars" id="influence-bars"></div>
    </div>
  </div>
</div>

<script>
// ========== FIRE, SMOKE & EMBER SYSTEM ==========
(function(){
  const canvas=document.getElementById('smoke-bg');
  const ctx=canvas.getContext('2d');
  let W,H;
  let time=0;
  function resize(){W=canvas.width=window.innerWidth;H=canvas.height=window.innerHeight}
  resize();
  window.addEventListener('resize',resize);

  // --- FLAME TONGUES (bottom of screen) ---
  class Flame{
    constructor(x){
      this.baseX=x;
      this.x=x;
      this.y=H;
      this.speed=1+Math.random()*2;
      this.maxH=80+Math.random()*180;
      this.width=30+Math.random()*50;
      this.phase=Math.random()*Math.PI*2;
      this.freq=0.02+Math.random()*0.03;
    }
    draw(t){
      const flicker=Math.sin(t*this.freq+this.phase)*0.3+0.7;
      const h=this.maxH*flicker;
      const sway=Math.sin(t*0.01+this.phase)*15;
      const x=this.baseX+sway;

      // Flame body — layered gradients for depth
      for(let layer=0;layer<3;layer++){
        const layerScale=1-layer*0.25;
        const lw=this.width*layerScale;
        const lh=h*layerScale;
        const grad=ctx.createRadialGradient(x,H,0,x,H-lh*0.5,lh);
        if(layer===0){
          grad.addColorStop(0,'rgba(255,200,50,0.0)');
          grad.addColorStop(0.2,'rgba(255,120,0,0.35)');
          grad.addColorStop(0.6,'rgba(220,50,0,0.2)');
          grad.addColorStop(1,'rgba(100,10,0,0)');
        }else if(layer===1){
          grad.addColorStop(0,'rgba(255,255,100,0.4)');
          grad.addColorStop(0.3,'rgba(255,160,20,0.3)');
          grad.addColorStop(0.7,'rgba(200,40,0,0.1)');
          grad.addColorStop(1,'rgba(80,10,0,0)');
        }else{
          grad.addColorStop(0,'rgba(255,255,220,0.5)');
          grad.addColorStop(0.2,'rgba(255,200,60,0.35)');
          grad.addColorStop(0.5,'rgba(255,100,0,0.15)');
          grad.addColorStop(1,'rgba(0,0,0,0)');
        }
        ctx.beginPath();
        ctx.ellipse(x,H,lw,lh,0,0,Math.PI*2);
        ctx.fillStyle=grad;
        ctx.fill();
      }
    }
  }

  const flames=[];
  // Create flames spread across bottom
  for(let x=-40;x<(typeof window!=='undefined'?window.innerWidth:1400)+40;x+=35+Math.random()*30){
    flames.push(new Flame(x));
  }

  // --- THICK SMOKE CLOUDS ---
  class SmokeCloud{
    constructor(){this.reset(true)}
    reset(init){
      this.x=Math.random()*W;
      this.y=init?(Math.random()*H):(H+50+Math.random()*100);
      this.vx=(Math.random()-0.5)*0.5;
      this.vy=-(0.4+Math.random()*0.7);
      this.size=60+Math.random()*120;
      this.maxSize=this.size+100+Math.random()*80;
      this.life=init?Math.random()*400:0;
      this.maxLife=350+Math.random()*300;
      const type=Math.random();
      if(type<0.3){this.r=50;this.g=45;this.b=40}        // dark smoke
      else if(type<0.55){this.r=70;this.g=55;this.b=35}   // brown smog
      else if(type<0.75){this.r=90;this.g=80;this.b=50}   // dirty haze
      else if(type<0.9){this.r=60;this.g=65;this.b=40}    // toxic green-grey
      else{this.r=100;this.g=60;this.b=25}                 // warm pollution
      this.maxAlpha=0.25+Math.random()*0.3;
    }
    update(){
      this.life++;
      this.x+=this.vx+Math.sin(this.life*0.008+this.x*0.001)*0.6;
      this.y+=this.vy;
      const t=this.life/this.maxLife;
      this.size=this.size+(this.maxSize-this.size)*t*0.3;
      if(this.life>this.maxLife||this.y<-this.size)this.reset(false);
    }
    draw(){
      const t=this.life/this.maxLife;
      let alpha;
      if(t<0.15)alpha=t/0.15;
      else if(t<0.5)alpha=1;
      else alpha=(1-t)/0.5;
      const a=Math.max(0,alpha*this.maxAlpha);
      const grad=ctx.createRadialGradient(this.x,this.y,this.size*0.1,this.x,this.y,this.size);
      grad.addColorStop(0,`rgba(${this.r},${this.g},${this.b},${a})`);
      grad.addColorStop(0.5,`rgba(${this.r},${this.g},${this.b},${a*0.6})`);
      grad.addColorStop(1,`rgba(${this.r},${this.g},${this.b},0)`);
      ctx.beginPath();
      ctx.fillStyle=grad;
      ctx.arc(this.x,this.y,this.size,0,Math.PI*2);
      ctx.fill();
    }
  }

  const smokeClouds=[];
  for(let i=0;i<80;i++)smokeClouds.push(new SmokeCloud());

  // --- BRIGHT EMBERS ---
  class Ember{
    constructor(){this.reset(true)}
    reset(init){
      this.x=Math.random()*W;
      this.y=init?(H*0.5+Math.random()*H*0.5):(H+5);
      this.vx=(Math.random()-0.5)*2;
      this.vy=-(1.5+Math.random()*3);
      this.size=1.5+Math.random()*3;
      this.life=init?Math.random()*150:0;
      this.maxLife=100+Math.random()*200;
      this.brightness=0.6+Math.random()*0.4;
      // Color: bright orange, yellow, or red
      const c=Math.random();
      if(c<0.4){this.r=255;this.g=180;this.b=30}       // bright orange
      else if(c<0.7){this.r=255;this.g=120;this.b=0}    // deep orange
      else if(c<0.9){this.r=255;this.g=220;this.b=50}   // yellow
      else{this.r=255;this.g=60;this.b=20}               // red hot
    }
    update(){
      this.life++;
      this.x+=this.vx+Math.sin(this.life*0.05)*0.8;
      this.y+=this.vy;
      this.vy*=0.997;
      this.vx*=0.999;
      if(this.life>this.maxLife||this.y<-20)this.reset(false);
    }
    draw(){
      const t=this.life/this.maxLife;
      let alpha=t<0.05?t/0.05:(1-t);
      alpha=Math.max(0,alpha*this.brightness);
      // Glow halo
      const grad=ctx.createRadialGradient(this.x,this.y,0,this.x,this.y,this.size*4);
      grad.addColorStop(0,`rgba(${this.r},${this.g},${this.b},${alpha*0.5})`);
      grad.addColorStop(0.3,`rgba(${this.r},${this.g},${this.b},${alpha*0.15})`);
      grad.addColorStop(1,`rgba(${this.r},${this.g},${this.b},0)`);
      ctx.beginPath();
      ctx.fillStyle=grad;
      ctx.arc(this.x,this.y,this.size*4,0,Math.PI*2);
      ctx.fill();
      // Core bright dot
      ctx.beginPath();
      ctx.fillStyle=`rgba(${Math.min(255,this.r+50)},${Math.min(255,this.g+50)},${Math.min(255,this.b+30)},${alpha})`;
      ctx.arc(this.x,this.y,this.size,0,Math.PI*2);
      ctx.fill();
    }
  }

  const embers=[];
  for(let i=0;i<60;i++)embers.push(new Ember());

  // --- ANIMATION LOOP ---
  function animate(){
    time++;
    ctx.clearRect(0,0,W,H);

    // Big fire glow across bottom
    const fireGrad=ctx.createLinearGradient(0,H,0,H-350);
    fireGrad.addColorStop(0,'rgba(255,80,0,0.35)');
    fireGrad.addColorStop(0.15,'rgba(255,50,0,0.2)');
    fireGrad.addColorStop(0.35,'rgba(180,30,0,0.1)');
    fireGrad.addColorStop(0.6,'rgba(80,15,0,0.04)');
    fireGrad.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=fireGrad;
    ctx.fillRect(0,H-350,W,350);

    // Smoke haze across top
    const hazeGrad=ctx.createLinearGradient(0,0,0,H*0.5);
    hazeGrad.addColorStop(0,'rgba(40,35,25,0.5)');
    hazeGrad.addColorStop(0.4,'rgba(50,40,30,0.2)');
    hazeGrad.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=hazeGrad;
    ctx.fillRect(0,0,W,H*0.5);

    // Draw flames
    flames.forEach(f=>f.draw(time));
    // Draw smoke clouds
    smokeClouds.forEach(s=>{s.update();s.draw()});
    // Draw embers on top
    embers.forEach(e=>{e.update();e.draw()});

    requestAnimationFrame(animate);
  }
  animate();
})();

// ========== STATE ==========
const INPUTS = [
  {name:'Task Complexity', desc:'How much AI actually helps with this task', defaultWeight:0.8},
  {name:'Time Saved', desc:'Efficiency gain from using AI', defaultWeight:0.6},
  {name:'Environmental Cost', desc:'Energy usage / environmental impact of the AI task', defaultWeight:-0.9},
  {name:'Alternative Difficulty', desc:'How hard it is to do the task without AI', defaultWeight:0.5},
  {name:'Task Importance', desc:'How much it matters to get this task right', defaultWeight:0.7},
];
// Fire-themed colors: flame, ember, toxic, warm purple, soot gold
const COLORS = ['#ff4d00','#ff8c00','#88aa22','#cc6644','#ffaa00'];

let weights = INPUTS.map(i=>i.defaultWeight);
let bias = 0.5;
let inputs = INPUTS.map(()=>0.5);
let trainingPoints = [];
let trainLabel = 1;
let trainSteps = 0;
let learningRate = 0.1;

// ========== MATH ==========
function sigmoid(z){return 1/(1+Math.exp(-z))}
function computeZ(x,w,b){let z=b;for(let i=0;i<x.length;i++)z+=x[i]*w[i];return z}
function forward(x,w,b){return sigmoid(computeZ(x,w,b))}

// ========== TABS ==========
document.querySelectorAll('.tab').forEach(tab=>{
  tab.addEventListener('click',()=>{
    document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
    document.querySelectorAll('.panel').forEach(p=>p.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById('panel-'+tab.dataset.tab).classList.add('active');
    update();
  });
});

// ========== BUILD SLIDERS ==========
const slidersContainer = document.getElementById('sliders-container');
INPUTS.forEach((inp,i)=>{
  const div = document.createElement('div');
  div.className = 'slider-group';
  div.innerHTML = `
    <div class="slider-label">
      <span class="name">${inp.name}<span class="weight-badge" id="wb-${i}">w: ${weights[i].toFixed(2)}</span></span>
      <span class="value" id="sv-${i}">0.50</span>
    </div>
    <div class="slider-desc">${inp.desc}</div>
    <input type="range" min="0" max="1" step="0.01" value="0.5" id="sl-${i}">
  `;
  slidersContainer.appendChild(div);
  div.querySelector('input').addEventListener('input',e=>{
    inputs[i]=parseFloat(e.target.value);
    update();
  });
});

document.getElementById('bias-slider').addEventListener('input',e=>{
  bias=parseFloat(e.target.value);
  update();
});

// ========== AXIS DROPDOWNS ==========
function populateDropdowns(){
  ['axis-x','axis-y','train-axis-x','train-axis-y'].forEach(id=>{
    const sel=document.getElementById(id);
    sel.innerHTML='';
    INPUTS.forEach((inp,i)=>{
      const opt=document.createElement('option');
      opt.value=i;opt.textContent=inp.name;
      sel.appendChild(opt);
    });
  });
  document.getElementById('axis-x').value=0;
  document.getElementById('axis-y').value=2;
  document.getElementById('train-axis-x').value=0;
  document.getElementById('train-axis-y').value=2;
}
populateDropdowns();

['axis-x','axis-y','train-axis-x','train-axis-y'].forEach(id=>{
  document.getElementById(id).addEventListener('change',()=>update());
});

// ========== NEURON SVG ==========
function drawNeuron(){
  const container=document.getElementById('neuron-viz');
  const w=container.clientWidth||500,h=360;
  const prob=forward(inputs,weights,bias);
  // Yes = fiery glow, No = ashy cool glow
  const hue=prob>=0.5?`rgba(255,77,0,${0.2+prob*0.4})`:`rgba(139,115,85,${0.2+(1-prob)*0.4})`;

  let svg=`<svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">`;
  // Defs for glow filter
  svg+=`<defs><filter id="glow"><feGaussianBlur stdDeviation="3" result="blur"/><feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs>`;
  const cx=w/2, cy=h/2, nr=36;
  const startX=60, endX=w-60;

  // Input nodes
  INPUTS.forEach((inp,i)=>{
    const iy=40+i*(h-80)/(INPUTS.length-1);
    const absW=Math.abs(weights[i]);
    const strokeW=1+absW*4;
    const col=weights[i]>=0?'#ff8c00':'#cc2200';
    const opacity=0.3+absW*0.6;
    svg+=`<line x1="${startX}" y1="${iy}" x2="${cx}" y2="${cy}" stroke="${col}" stroke-width="${strokeW}" opacity="${opacity}"/>`;
    svg+=`<circle cx="${startX}" cy="${iy}" r="18" fill="#261a14" stroke="${COLORS[i]}" stroke-width="2"/>`;
    svg+=`<text x="${startX}" y="${iy+4}" text-anchor="middle" fill="${COLORS[i]}" font-size="11" font-weight="600">${inputs[i].toFixed(2)}</text>`;
    const shortName=inp.name.split(' ').map(w=>w[0]).join('');
    svg+=`<text x="${startX}" y="${iy-24}" text-anchor="middle" fill="#9a7e6e" font-size="10">${shortName}</text>`;
  });

  // Central neuron with fire/ash glow
  const neuronStroke=prob>=0.5?'#ff4d00':'#8b7355';
  svg+=`<circle cx="${cx}" cy="${cy}" r="${nr+12}" fill="none" stroke="${hue}" stroke-width="2" opacity="0.4" filter="url(#glow)"/>`;
  svg+=`<circle cx="${cx}" cy="${cy}" r="${nr}" fill="#261a14" stroke="${neuronStroke}" stroke-width="3"/>`;
  svg+=`<text x="${cx}" y="${cy-4}" text-anchor="middle" fill="#f0ddd0" font-size="13" font-weight="700">&sigma;</text>`;
  svg+=`<text x="${cx}" y="${cy+14}" text-anchor="middle" fill="${neuronStroke}" font-size="11" font-weight="600">${(prob*100).toFixed(1)}%</text>`;

  // Output arrow
  const outCol=prob>=0.5?'#ff4d00':'#8b7355';
  svg+=`<line x1="${cx+nr+4}" y1="${cy}" x2="${endX-20}" y2="${cy}" stroke="${outCol}" stroke-width="3" opacity="0.7"/>`;
  svg+=`<circle cx="${endX}" cy="${cy}" r="24" fill="#261a14" stroke="${outCol}" stroke-width="2.5"/>`;
  const outText=prob>=0.5?'YES':'NO';
  svg+=`<text x="${endX}" y="${cy+5}" text-anchor="middle" fill="${outCol}" font-size="14" font-weight="700">${outText}</text>`;

  svg+=`</svg>`;
  container.innerHTML=svg;
}

// ========== OUTPUT DISPLAY ==========
function updateOutput(){
  const prob=forward(inputs,weights,bias);
  const pEl=document.getElementById('output-prob');
  const lEl=document.getElementById('output-label');
  pEl.textContent=(prob*100).toFixed(1)+'%';
  let label,color;
  if(prob>=0.7){label='Definitely worth it';color='#ff4d00'}
  else if(prob>=0.5){label='Probably worth it';color='#ff8c00'}
  else if(prob>=0.3){label='Probably not worth it';color='#8b7355'}
  else{label='Not worth it';color='#6b5b4a'}
  pEl.style.color=color;
  lEl.style.color=color;
  lEl.textContent=label;
}

// ========== MATH BREAKDOWN ==========
function updateMath(){
  const panel=document.getElementById('math-breakdown');
  let html='';
  let z=bias;
  INPUTS.forEach((inp,i)=>{
    const contrib=inputs[i]*weights[i];
    z+=contrib;
    const cls=contrib>=0?'pos':'neg';
    html+=`<div class="math-row"><span class="label">${inp.name.split(' ')[0]}: ${inputs[i].toFixed(2)} &times; ${weights[i].toFixed(2)}</span><span class="val ${cls}">${contrib>=0?'+':''}${contrib.toFixed(3)}</span></div>`;
  });
  const bCls=bias>=0?'pos':'neg';
  html+=`<div class="math-row"><span class="label">Bias</span><span class="val ${bCls}">${bias>=0?'+':''}${bias.toFixed(3)}</span></div>`;
  html+=`<div class="math-row" style="border-top:2px solid var(--border);padding-top:.5rem"><span class="label" style="color:var(--gold)">z = </span><span class="val" style="color:var(--gold)">${z.toFixed(4)}</span></div>`;
  const out=sigmoid(z);
  html+=`<div class="math-row"><span class="label" style="color:var(--gold)">&sigma;(z) = </span><span class="val" style="color:${out>=0.5?'#ff4d00':'#8b7355'}">${out.toFixed(4)}</span></div>`;
  panel.innerHTML=html;
}

// ========== WEIGHT BADGES & SLIDER VALUES ==========
function updateSliderDisplay(){
  INPUTS.forEach((inp,i)=>{
    document.getElementById('sv-'+i).textContent=inputs[i].toFixed(2);
    const wb=document.getElementById('wb-'+i);
    wb.textContent='w: '+weights[i].toFixed(2);
    wb.style.color=weights[i]>=0?'#ff8c00':'#cc2200';
  });
  document.getElementById('bias-val').textContent=(bias>=0?'+':'')+bias.toFixed(2);
}

// ========== DECISION BOUNDARY HEATMAP ==========
function drawBoundary(canvasId, axisXId, axisYId, showTrainingPoints){
  const canvas=document.getElementById(canvasId);
  const ctx=canvas.getContext('2d');
  const W=canvas.width, H=canvas.height;
  const xi=parseInt(document.getElementById(axisXId).value);
  const yi=parseInt(document.getElementById(axisYId).value);
  const res=100;

  const imgData=ctx.createImageData(W,H);

  for(let py=0;py<res;py++){
    for(let px=0;px<res;px++){
      const xv=px/(res-1);
      const yv=1-py/(res-1);
      const testInputs=[...inputs];
      testInputs[xi]=xv;
      testInputs[yi]=yv;
      const p=forward(testInputs,weights,bias);

      let r,g,b;
      if(p<0.5){
        // Cool ash/smoke zone (dark gray-brown to smoky)
        const t=p/0.5;
        r=Math.round(25+t*80);
        g=Math.round(22+t*60);
        b=Math.round(20+t*40);
      } else {
        // Fire zone (warm orange to bright flame)
        const t=(p-0.5)/0.5;
        r=Math.round(105+t*150);
        g=Math.round(82-t*40);
        b=Math.round(60-t*55);
      }

      for(let dy=0;dy<Math.ceil(H/res);dy++){
        for(let dx=0;dx<Math.ceil(W/res);dx++){
          const ix=Math.floor(px*W/res)+dx;
          const iy=Math.floor(py*H/res)+dy;
          if(ix<W&&iy<H){
            const idx=(iy*W+ix)*4;
            imgData.data[idx]=r;
            imgData.data[idx+1]=g;
            imgData.data[idx+2]=b;
            imgData.data[idx+3]=255;
          }
        }
      }
    }
  }
  ctx.putImageData(imgData,0,0);

  // Decision boundary contour (bright yellow-gold line at 50%)
  ctx.strokeStyle='#ffcc00';
  ctx.lineWidth=2.5;
  ctx.shadowColor='#ff8800';
  ctx.shadowBlur=6;
  ctx.setLineDash([]);
  ctx.beginPath();
  let started=false;
  for(let px=0;px<res;px++){
    const xv=px/(res-1);
    let lo=0,hi=1,yv=0.5;
    for(let iter=0;iter<30;iter++){
      const mid=(lo+hi)/2;
      const testInputs=[...inputs];
      testInputs[xi]=xv;testInputs[yi]=mid;
      const p=forward(testInputs,weights,bias);
      if(p>0.5)hi=mid;else lo=mid;
    }
    yv=(lo+hi)/2;
    if(yv>0.01&&yv<0.99){
      const sx=px*W/res;
      const sy=(1-yv)*H;
      if(!started){ctx.moveTo(sx,sy);started=true}else ctx.lineTo(sx,sy);
    }
  }
  ctx.stroke();
  ctx.shadowBlur=0;

  // Crosshair
  const curX=inputs[xi]*W;
  const curY=(1-inputs[yi])*H;
  ctx.strokeStyle='rgba(240,221,208,0.5)';
  ctx.lineWidth=1;
  ctx.setLineDash([4,4]);
  ctx.beginPath();ctx.moveTo(curX,0);ctx.lineTo(curX,H);ctx.stroke();
  ctx.beginPath();ctx.moveTo(0,curY);ctx.lineTo(W,curY);ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle='#f0ddd0';
  ctx.beginPath();ctx.arc(curX,curY,5,0,Math.PI*2);ctx.fill();
  ctx.strokeStyle='#000';ctx.lineWidth=1.5;ctx.stroke();

  // Axis labels
  ctx.fillStyle='#9a7e6e';
  ctx.font='12px system-ui';
  ctx.textAlign='center';
  ctx.fillText(INPUTS[xi].name,W/2,H-6);
  ctx.save();
  ctx.translate(14,H/2);ctx.rotate(-Math.PI/2);
  ctx.fillText(INPUTS[yi].name,0,0);
  ctx.restore();

  ctx.fillStyle='#7a6a5a';ctx.font='10px system-ui';
  ctx.textAlign='center';
  for(let t=0;t<=1;t+=0.25){
    ctx.fillText(t.toFixed(2),t*W,H-18);
  }
  ctx.textAlign='right';
  for(let t=0;t<=1;t+=0.25){
    ctx.fillText(t.toFixed(2),32,(1-t)*H+4);
  }

  // Training points
  if(showTrainingPoints){
    const txi=parseInt(document.getElementById('train-axis-x').value);
    const tyi=parseInt(document.getElementById('train-axis-y').value);
    trainingPoints.forEach(pt=>{
      const px=pt.x[txi]*W;
      const py=(1-pt.x[tyi])*H;
      ctx.beginPath();
      ctx.arc(px,py,7,0,Math.PI*2);
      ctx.fillStyle=pt.y===1?'rgba(255,77,0,0.85)':'rgba(139,115,85,0.85)';
      ctx.fill();
      ctx.strokeStyle='#f0ddd0';ctx.lineWidth=1.5;ctx.stroke();
    });
  }
}

// ========== TRAINING ==========
document.getElementById('label-yes').addEventListener('click',()=>{
  trainLabel=1;
  document.getElementById('label-yes').classList.add('active');
  document.getElementById('label-no').classList.remove('active');
});
document.getElementById('label-no').addEventListener('click',()=>{
  trainLabel=0;
  document.getElementById('label-no').classList.add('active');
  document.getElementById('label-yes').classList.remove('active');
});

document.getElementById('training-canvas').addEventListener('click',e=>{
  const rect=e.target.getBoundingClientRect();
  const px=(e.clientX-rect.left)/rect.width;
  const py=1-(e.clientY-rect.top)/rect.height;
  const xi=parseInt(document.getElementById('train-axis-x').value);
  const yi=parseInt(document.getElementById('train-axis-y').value);
  const point=[...inputs];
  point[xi]=Math.max(0,Math.min(1,px));
  point[yi]=Math.max(0,Math.min(1,py));
  trainingPoints.push({x:point,y:trainLabel});
  update();
});

function trainStep(){
  if(trainingPoints.length===0)return;
  const lr=parseFloat(document.getElementById('lr-input').value)||0.1;
  const gradW=new Array(weights.length).fill(0);
  let gradB=0;
  trainingPoints.forEach(pt=>{
    const pred=forward(pt.x,weights,bias);
    const err=pred-pt.y;
    for(let i=0;i<weights.length;i++){
      gradW[i]+=err*pt.x[i];
    }
    gradB+=err;
  });
  const n=trainingPoints.length;
  for(let i=0;i<weights.length;i++){
    weights[i]-=lr*gradW[i]/n;
  }
  bias-=lr*gradB/n;
  trainSteps++;
  bias=Math.max(-3,Math.min(3,bias));
  document.getElementById('bias-slider').value=bias;
}

document.getElementById('btn-step').addEventListener('click',()=>{trainStep();update()});
document.getElementById('btn-train').addEventListener('click',()=>{
  for(let i=0;i<50;i++)trainStep();
  update();
});
document.getElementById('btn-reset').addEventListener('click',()=>{
  weights=INPUTS.map(i=>i.defaultWeight);
  bias=0.5;
  trainingPoints=[];
  trainSteps=0;
  document.getElementById('bias-slider').value=bias;
  update();
});
document.getElementById('lr-input').addEventListener('change',e=>{
  learningRate=parseFloat(e.target.value)||0.1;
});

function updateTrainingStats(){
  const container=document.getElementById('training-stats');
  let correct=0;
  trainingPoints.forEach(pt=>{
    const pred=forward(pt.x,weights,bias);
    if((pred>=0.5&&pt.y===1)||(pred<0.5&&pt.y===0))correct++;
  });
  const acc=trainingPoints.length>0?(correct/trainingPoints.length*100).toFixed(1):'--';

  let loss=0;
  trainingPoints.forEach(pt=>{
    const pred=Math.max(1e-7,Math.min(1-1e-7,forward(pt.x,weights,bias)));
    loss+=-(pt.y*Math.log(pred)+(1-pt.y)*Math.log(1-pred));
  });
  loss=trainingPoints.length>0?(loss/trainingPoints.length).toFixed(4):'--';

  let html='';
  INPUTS.forEach((inp,i)=>{
    const col=weights[i]>=0?'#ff8c00':'#cc2200';
    html+=`<div class="stat-box"><div class="stat-label">${inp.name.split(' ')[0]} w</div><div class="stat-val" style="color:${col}">${weights[i].toFixed(3)}</div></div>`;
  });
  html+=`<div class="stat-box"><div class="stat-label">Bias</div><div class="stat-val" style="color:#88aa22">${bias.toFixed(3)}</div></div>`;
  html+=`<div class="stat-box"><div class="stat-label">Steps</div><div class="stat-val">${trainSteps}</div></div>`;
  html+=`<div class="stat-box"><div class="stat-label">Points</div><div class="stat-val">${trainingPoints.length}</div></div>`;
  html+=`<div class="stat-box"><div class="stat-label">Accuracy</div><div class="stat-val">${acc}%</div></div>`;
  html+=`<div class="stat-box"><div class="stat-label">Loss</div><div class="stat-val">${loss}</div></div>`;
  container.innerHTML=html;
}

// ========== SENSITIVITY ANALYSIS ==========
function drawSensitivity(){
  const canvas=document.getElementById('sensitivity-canvas');
  const ctx=canvas.getContext('2d');
  const W=canvas.width,H=canvas.height;
  const pad={top:20,right:20,bottom:40,left:50};
  const pw=W-pad.left-pad.right, ph=H-pad.top-pad.bottom;

  ctx.clearRect(0,0,W,H);

  // Grid
  ctx.strokeStyle='#261a14';ctx.lineWidth=1;
  for(let i=0;i<=10;i++){
    const x=pad.left+i*pw/10;
    const y=pad.top+i*ph/10;
    ctx.beginPath();ctx.moveTo(x,pad.top);ctx.lineTo(x,pad.top+ph);ctx.stroke();
    ctx.beginPath();ctx.moveTo(pad.left,y);ctx.lineTo(pad.left+pw,y);ctx.stroke();
  }

  // 50% line
  ctx.strokeStyle='#ffaa00';ctx.lineWidth=1;ctx.setLineDash([4,4]);
  const y50=pad.top+ph*0.5;
  ctx.beginPath();ctx.moveTo(pad.left,y50);ctx.lineTo(pad.left+pw,y50);ctx.stroke();
  ctx.setLineDash([]);

  // Curves
  const steps=100;
  INPUTS.forEach((inp,i)=>{
    ctx.strokeStyle=COLORS[i];ctx.lineWidth=2.5;
    ctx.beginPath();
    for(let s=0;s<=steps;s++){
      const xv=s/steps;
      const testInputs=[...inputs];
      testInputs[i]=xv;
      const p=forward(testInputs,weights,bias);
      const x=pad.left+xv*pw;
      const y=pad.top+(1-p)*ph;
      if(s===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // Current position marker
    const curX=pad.left+inputs[i]*pw;
    const testI=[...inputs];
    const pAtCur=forward(testI,weights,bias);
    const dotY=pad.top+(1-pAtCur)*ph;
    ctx.fillStyle=COLORS[i];
    ctx.beginPath();ctx.arc(curX,dotY,5,0,Math.PI*2);ctx.fill();
    ctx.strokeStyle='#f0ddd0';ctx.lineWidth=1;ctx.stroke();
  });

  // Axis labels
  ctx.fillStyle='#7a6a5a';ctx.font='11px system-ui';
  ctx.textAlign='center';
  for(let i=0;i<=4;i++){
    ctx.fillText((i/4).toFixed(2),pad.left+i*pw/4,H-pad.bottom+18);
  }
  ctx.textAlign='right';
  for(let i=0;i<=4;i++){
    ctx.fillText((i/4*100).toFixed(0)+'%',pad.left-8,pad.top+(1-i/4)*ph+4);
  }
  ctx.textAlign='center';
  ctx.fillText('Input Value',W/2,H-5);
  ctx.save();ctx.translate(12,H/2);ctx.rotate(-Math.PI/2);
  ctx.fillText('Output Probability',0,0);ctx.restore();

  // Legend
  const legend=document.getElementById('sensitivity-legend');
  legend.innerHTML=INPUTS.map((inp,i)=>`<div class="legend-item"><div class="legend-dot" style="background:${COLORS[i]}"></div>${inp.name}</div>`).join('');
}

function drawInfluenceBars(){
  const container=document.getElementById('influence-bars');
  const maxW=Math.max(...weights.map(Math.abs),0.01);
  container.innerHTML=INPUTS.map((inp,i)=>{
    const absW=Math.abs(weights[i]);
    const pct=(absW/maxW*100).toFixed(1);
    const col=weights[i]>=0?'#ff8c00':'#cc2200';
    return `<div class="inf-row">
      <span class="inf-label">${inp.name}</span>
      <div class="inf-bar-wrap"><div class="inf-bar" style="width:${pct}%;background:${col}"></div></div>
      <span class="inf-val" style="color:${col}">${weights[i]>=0?'+':''}${weights[i].toFixed(3)}</span>
    </div>`;
  }).join('');
}

// ========== MASTER UPDATE ==========
function update(){
  updateSliderDisplay();
  updateOutput();
  drawNeuron();
  updateMath();

  const activeTab=document.querySelector('.tab.active').dataset.tab;
  if(activeTab==='boundary'){
    drawBoundary('boundary-canvas','axis-x','axis-y',false);
  }
  if(activeTab==='training'){
    drawBoundary('training-canvas','train-axis-x','train-axis-y',true);
    updateTrainingStats();
  }
  if(activeTab==='sensitivity'){
    drawSensitivity();
    drawInfluenceBars();
  }
}

// Initial render
update();
window.addEventListener('resize',()=>update());
</script>
</body>
</html>
